---
phase: 05-main-pricing-algorithm
plan: 02
type: execute
---

<objective>
Create REST API endpoint for price calculation and validate with integration tests.

Purpose: Expose the pricing engine via POST /api/pricing/calculate endpoint with proper validation, authentication, and full end-to-end testing.

Output: Production-ready API endpoint with integration tests covering the full flow from HTTP request to database to response.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-phase.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-main-pricing-algorithm/05-01-SUMMARY.md

**Phase dependencies:**
- Plan 05-01: PricingService implementation complete

**Tech stack available:**
- FastAPI 0.115.0 with dependency injection
- Pydantic 2.10.1 for request/response validation
- SQLAlchemy session management via `get_user_db()`
- JWT authentication via `get_current_user()`
- Integration tests in `backend/tests/integration/`

**Established patterns:**
- API routes in `backend/api/` organized by domain
- Service Layer: routes delegate to services
- Dependency injection for DB session + auth
- Response models for typed returns
- HTTP status codes via `status.HTTP_XXX`
- Exception handling: convert ServiceError → HTTPException

**Key files to reference:**
- `backend/api/products.py` - Example product routes
- `backend/services/pricing_service.py` - Service from Plan 05-01
- `backend/schemas/pricing.py` - PriceInput/PriceOutput
- `backend/shared/dependencies.py` - get_user_db, get_current_user

**Authentication:**
- All pricing endpoints require authentication
- Use `get_current_user()` dependency for user context
- Repositories use user-specific schema via `get_user_db()`
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create POST /api/pricing/calculate endpoint</name>
  <files>backend/api/pricing.py</files>
  <action>
    Create new API module `backend/api/pricing.py`:

    **Route definition:**
    ```python
    from fastapi import APIRouter, Depends, status
    from fastapi.responses import JSONResponse
    from sqlalchemy.orm import Session

    from models.public.user import User
    from schemas.pricing import PriceInput, PriceOutput
    from services.pricing_service import PricingService
    from services.pricing_generation_service import PricingGenerationService
    from repositories.brand_group_repository import BrandGroupRepository
    from repositories.model_repository import ModelRepository
    from shared.dependencies import get_user_db, get_current_user
    from shared.exceptions import ServiceError

    router = APIRouter(prefix="/api/pricing", tags=["pricing"])

    @router.post(
        "/calculate",
        response_model=PriceOutput,
        status_code=status.HTTP_200_OK,
        summary="Calculate product price with 3 levels",
        description="Orchestrates all pricing calculators to generate quick/standard/premium prices with detailed breakdown"
    )
    def calculate_price(
        input: PriceInput,
        db_user: tuple[Session, User] = Depends(get_user_db),
        current_user: User = Depends(get_current_user)
    ) -> PriceOutput:
        """
        Calculate product price using pricing algorithm.

        Fetches/generates BrandGroup and Model data, applies all 6 adjustment calculators,
        returns 3 price levels (quick/standard/premium) with detailed breakdown.

        Args:
            input: PriceInput with product attributes and adjustment parameters
            db_user: Database session with user schema set
            current_user: Authenticated user

        Returns:
            PriceOutput with 3 price levels and adjustment breakdown

        Raises:
            HTTPException 400: Invalid input data
            HTTPException 500: Service error (LLM failure, DB error)
        """
        db, user = db_user

        # Initialize dependencies
        brand_group_repo = BrandGroupRepository(db)
        model_repo = ModelRepository(db)
        generation_service = PricingGenerationService(db)

        # Create pricing service
        pricing_service = PricingService(
            db=db,
            brand_group_repo=brand_group_repo,
            model_repo=model_repo,
            generation_service=generation_service
        )

        try:
            # Calculate price
            result = pricing_service.calculatePrice(input)
            return result

        except ValueError as e:
            # Validation errors (group determination, invalid input)
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=str(e)
            )
        except ServiceError as e:
            # Service errors (LLM failure, generation error)
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Pricing calculation failed: {str(e)}"
            )
        except Exception as e:
            # Unexpected errors
            logger.error(f"Unexpected error in calculate_price: {e}", exc_info=True)
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="An unexpected error occurred during price calculation"
            )
    ```

    **Register router in `backend/main.py`:**
    ```python
    from api import pricing
    app.include_router(pricing.router)
    ```

    **Why this approach:**
    - Dependency injection for db + user (multi-tenant isolation)
    - Authentication required (get_current_user)
    - Service layer pattern (route delegates to PricingService)
    - Proper error handling (ValueError → 400, ServiceError → 500)
    - OpenAPI documentation via docstring + response_model
    - Clean separation: route handles HTTP, service handles business logic
  </action>
  <verify>
    1. `uvicorn main:app --reload` starts without errors
    2. OpenAPI docs show POST /api/pricing/calculate
    3. Endpoint requires authentication (401 without token)
    4. Can import pricing router in main.py
    5. No syntax or type errors
  </verify>
  <done>
    - backend/api/pricing.py exists with calculate_price endpoint
    - Route registered in main.py
    - Authentication via get_current_user required
    - PricingService dependency injection implemented
    - Error handling for ValueError and ServiceError
    - OpenAPI documentation complete
  </done>
</task>

<task type="auto">
  <name>Task 2: Write integration tests for /api/pricing/calculate endpoint</name>
  <files>backend/tests/integration/test_pricing_api.py</files>
  <action>
    Create integration test file with real database and full flow testing:

    **Fixtures:**
    ```python
    import pytest
    from fastapi.testclient import TestClient
    from sqlalchemy.orm import Session

    from main import app
    from tests.conftest import db_session, test_user, auth_headers
    # Reuse existing fixtures from conftest.py

    @pytest.fixture
    def client():
        return TestClient(app)
    ```

    **Test classes:**

    1. **TestPricingCalculateAuthentication** (3 tests):
       - Without auth token → 401 Unauthorized
       - With invalid token → 401 Unauthorized
       - With valid token → 200 OK (baseline)

    2. **TestPricingCalculateValidation** (5-7 tests):
       - Missing required fields → 422 Unprocessable Entity
       - Invalid condition_score (out of range 0-5) → 400 Bad Request
       - Invalid origin → 400 Bad Request
       - Invalid decade (not in DECADE_COEFFICIENTS) → 400 Bad Request
       - Valid minimal input → 200 OK
       - Valid full input with all fields → 200 OK

    3. **TestPricingCalculateFlow** (8-10 tests):
       - **BrandGroup exists in DB**: Fetch only, no generation, prices calculated
       - **BrandGroup missing**: Generate via LLM, save to DB, prices calculated
       - **Model exists in DB**: Fetch only, coefficient applied
       - **Model missing**: Generate via LLM, save to DB, coefficient applied
       - **No model_name provided**: model_coeff = 1.0, prices calculated
       - **With all positive adjustments**: premium > standard > quick, breakdown correct
       - **With negative adjustments**: prices lower, breakdown shows negatives
       - **Multiple calls with same brand+group**: Second call uses cached DB entry (no re-generation)
       - **Response structure**: All fields present (quick/standard/premium, base_price, breakdown)
       - **Price ratios**: quick = standard × 0.75, premium = standard × 1.30

    4. **TestPricingCalculateErrors** (3-5 tests):
       - **Group determination fails** (invalid category) → 400 Bad Request
       - **LLM generation fails** (mock timeout) → 500 Internal Server Error
       - **Database error** (mock DB failure) → 500 Internal Server Error
       - Error responses include clear messages
       - Errors logged appropriately

    **Total: ~20 tests**

    **Test strategy:**
    - Use real test database (Docker postgres)
    - Real PricingService, repositories, calculators
    - Mock only external LLM calls if needed (or use integration with Gemini)
    - Use `auth_headers` fixture for authentication
    - Verify DB state (BrandGroup/Model saved after generation)
    - Test full request → response cycle

    **Example test:**
    ```python
    def test_calculate_price_with_existing_brand_group(client, db_session, auth_headers):
        # Given: BrandGroup exists in DB
        brand_group = BrandGroup(brand="Nike", group="sneakers_leather", base_price=Decimal("120.00"))
        db_session.add(brand_group)
        db_session.commit()

        # When: Calculate price
        response = client.post(
            "/api/pricing/calculate",
            json={
                "brand": "Nike",
                "category": "sneakers",
                "materials": ["leather"],
                "condition_score": 4,
                "supplements": [],
                "condition_sensitivity": 1.0,
                "actual_origin": "China",
                "expected_origins": ["China"],
                "actual_decade": "2020s",
                "expected_decades": ["2020s"],
                "actual_trends": [],
                "expected_trends": [],
                "actual_features": [],
                "expected_features": []
            },
            headers=auth_headers
        )

        # Then: Success with correct structure
        assert response.status_code == 200
        data = response.json()
        assert "quick_price" in data
        assert "standard_price" in data
        assert "premium_price" in data
        assert data["base_price"] == "120.00"
        assert data["quick_price"] < data["standard_price"] < data["premium_price"]
    ```

    **Why integration tests:**
    - Unit tests validate components in isolation
    - Integration tests validate full flow end-to-end
    - Catch issues at component boundaries
    - Verify authentication, DB transactions, error handling
    - Production-like environment (real DB, real HTTP)
  </action>
  <verify>
    Run: `pytest backend/tests/integration/test_pricing_api.py -v`

    Expected:
    - All ~20 tests pass
    - Real database used (Docker postgres test container)
    - Full flow validated (HTTP → Service → DB → Response)
    - Authentication tested
    - Error scenarios covered
    - Test execution < 30 seconds
  </verify>
  <done>
    - test_pricing_api.py exists with 4 test classes
    - ~20 integration tests covering auth, validation, flow, errors
    - All tests pass
    - Real database used (not mocked)
    - Full request/response cycle tested
    - BrandGroup/Model generation flow validated
    - Error handling verified
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pytest backend/tests/integration/test_pricing_api.py -v` passes all tests
- [ ] `uvicorn main:app --reload` starts without errors
- [ ] OpenAPI docs accessible at http://localhost:8000/docs
- [ ] POST /api/pricing/calculate visible in OpenAPI docs
- [ ] Endpoint requires authentication (401 without token)
- [ ] Can successfully calculate price with valid input + auth token
</verification>

<success_criteria>

- All tasks completed
- POST /api/pricing/calculate endpoint functional
- ~20 integration tests passing
- Full flow validated (HTTP → Service → DB → Response)
- Authentication enforced
- Error handling robust
- Ready for error handling polish (Plan 05-03)
</success_criteria>

<output>
After completion, create `.planning/phases/05-main-pricing-algorithm/05-02-SUMMARY.md`:

# Phase 5 Plan 2: API Endpoint & Integration Summary

**[Substantive one-liner describing the REST API and integration testing]**

## Accomplishments

- POST /api/pricing/calculate endpoint exposed
- Authentication via JWT required
- Full request/response cycle tested
- ~20 integration tests covering auth, validation, flow, errors
- OpenAPI documentation complete

## Files Created/Modified

- `backend/api/pricing.py` - REST API endpoint
- `backend/main.py` - Router registration
- `backend/tests/integration/test_pricing_api.py` - Integration tests (~20 tests)

## Decisions Made

- Dependency injection for db + user (multi-tenant support)
- Service layer pattern (route delegates to PricingService)
- Error handling: ValueError → 400, ServiceError → 500
- Integration tests with real database (not mocked)

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 05-03-PLAN.md (Error Handling & Polish)
</output>
