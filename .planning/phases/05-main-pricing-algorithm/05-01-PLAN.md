---
phase: 05-main-pricing-algorithm
plan: 01
type: execute
---

<objective>
Implement the core PricingService that orchestrates all 6 calculators and generates 3 price levels.

Purpose: Create the central pricing engine that fetches/generates BrandGroup & Model data, applies all adjustments, and returns quick/standard/premium prices with detailed breakdown.

Output: Working PricingService with comprehensive unit tests, ready for API integration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-phase.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-adjustment-calculators/04-03-SUMMARY.md

**Phase dependencies:**
- Phase 1: BrandGroup & Model tables + repositories (brand_group_repository, model_repository)
- Phase 2: group_determination logic (determineGroup function)
- Phase 3: PricingGenerationService (generateBrandGroup, generateModel methods)
- Phase 4: All 6 adjustment calculators (calculateModelCoefficient, calculateConditionAdjustment, etc.)

**Tech stack available:**
- Python 3.11+ with Decimal for precision
- SQLAlchemy repositories (BrandGroupRepository, ModelRepository)
- PricingGenerationService with Gemini integration
- All 6 adjustment calculators in `backend/services/pricing/adjustment_calculators.py`

**Established patterns:**
- Service layer in `backend/services/` (ProductService, AuthService)
- Clean Architecture: Service → Repository → Model
- Type hints with Pydantic schemas for validation
- Unit tests in `backend/tests/unit/services/`
- Google-style docstrings

**Key files to reference:**
- `backend/services/pricing/adjustment_calculators.py` - All calculators
- `backend/services/pricing_generation_service.py` - LLM generation
- `backend/repositories/brand_group_repository.py` - BrandGroup data access
- `backend/repositories/model_repository.py` - Model data access
- `backend/services/pricing/group_determination.py` - Group logic

**Formula (from ROADMAP):**
```
PRICE = BASE_PRICE × MODEL_COEFF × (1 + ADJUSTMENTS)

Where ADJUSTMENTS = condition_adj + origin_adj + decade_adj + trend_adj + feature_adj

3 price levels:
- Quick: PRICE × 0.75
- Standard: PRICE × 1.0
- Premium: PRICE × 1.30
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PricingService with data fetching/generation logic</name>
  <files>backend/services/pricing_service.py</files>
  <action>
    Create `PricingService` class with:

    **Dependencies (inject in constructor):**
    - `db: Session` - Database session
    - `brand_group_repo: BrandGroupRepository`
    - `model_repo: ModelRepository`
    - `generation_service: PricingGenerationService`

    **Method: `calculatePrice(input: PriceInput) -> PriceOutput`**

    **PriceInput (Pydantic):**
    ```python
    class PriceInput(BaseModel):
        # Product attributes
        brand: str
        category: str
        materials: list[str]
        model_name: Optional[str]

        # Adjustment inputs
        condition_score: int  # 0-5
        supplements: list[str]
        condition_sensitivity: Decimal
        actual_origin: str
        expected_origins: list[str]
        actual_decade: str
        expected_decades: list[str]
        actual_trends: list[str]
        expected_trends: list[str]
        actual_features: list[str]
        expected_features: list[str]
    ```

    **Logic flow:**
    1. Determine group using `determineGroup(category, materials)`
    2. Fetch BrandGroup from DB (`brand_group_repo.get_by_brand_and_group(brand, group)`)
    3. If BrandGroup not found: generate via `generation_service.generateBrandGroup(brand, group)`, save to DB
    4. Get base_price from BrandGroup
    5. If model_name provided:
       - Fetch Model from DB (`model_repo.get_by_brand_group_and_model(brand_group_id, model_name)`)
       - If Model not found: generate via `generation_service.generateModel(brand, group, model_name, base_price)`, save to DB
       - Extract model_coeff from Model
    6. If no model_name: model_coeff = 1.0
    7. Return dict with `{"base_price": Decimal, "model_coeff": Decimal, "brand_group": BrandGroup, "model": Optional[Model]}`

    **Error handling:**
    - Raise `ValueError` if group determination fails
    - Raise `ServiceError` if LLM generation fails after retries
    - Log all generation attempts (brand_group generation, model generation)

    **Why this approach:**
    - Separation of concerns: data fetching separate from calculation
    - Caching via DB: only generate if missing
    - Testable: can mock repositories and generation service
  </action>
  <verify>
    1. Import PricingService succeeds
    2. Can instantiate with mocked dependencies
    3. Method signature matches specification
    4. No syntax errors, passes type checking
  </verify>
  <done>
    - PricingService class exists in backend/services/pricing_service.py
    - Constructor accepts db, repositories, generation_service
    - calculatePrice() method stubbed with correct input/output types
    - Data fetching/generation logic implemented
    - Error handling for missing data and generation failures
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement price calculation with all 6 calculators and 3 levels</name>
  <files>backend/services/pricing_service.py, backend/schemas/pricing.py</files>
  <action>
    **1. Complete `calculatePrice()` method:**

    After data fetching (from Task 1), add calculation logic:

    1. Call all 6 calculators:
       ```python
       from services.pricing.adjustment_calculators import (
           calculateModelCoefficient,
           calculateConditionAdjustment,
           calculateOriginAdjustment,
           calculateDecadeAdjustment,
           calculateTrendAdjustment,
           calculateFeatureAdjustment
       )

       # If model exists
       model_coeff = calculateModelCoefficient(model) if model else Decimal("1.0")

       # Calculate all adjustments
       condition_adj = calculateConditionAdjustment(
           input.condition_score, input.supplements, input.condition_sensitivity
       )
       origin_adj = calculateOriginAdjustment(input.actual_origin, input.expected_origins)
       decade_adj = calculateDecadeAdjustment(input.actual_decade, input.expected_decades)
       trend_adj = calculateTrendAdjustment(input.actual_trends, input.expected_trends)
       feature_adj = calculateFeatureAdjustment(input.actual_features, input.expected_features)
       ```

    2. Apply formula:
       ```python
       total_adjustment = condition_adj + origin_adj + decade_adj + trend_adj + feature_adj
       adjusted_price = base_price * model_coeff * (1 + total_adjustment)
       ```

    3. Calculate 3 price levels:
       ```python
       quick_price = (adjusted_price * Decimal("0.75")).quantize(Decimal("0.01"))
       standard_price = adjusted_price.quantize(Decimal("0.01"))
       premium_price = (adjusted_price * Decimal("1.30")).quantize(Decimal("0.01"))
       ```

    **2. Create Pydantic schemas in `backend/schemas/pricing.py`:**

    ```python
    class PriceInput(BaseModel):
        # (Already defined in Task 1, refine here if needed)
        model_config = {"from_attributes": True}

    class AdjustmentBreakdown(BaseModel):
        condition: Decimal
        origin: Decimal
        decade: Decimal
        trend: Decimal
        feature: Decimal
        total: Decimal

    class PriceOutput(BaseModel):
        # Price levels
        quick_price: Decimal
        standard_price: Decimal
        premium_price: Decimal

        # Calculation breakdown
        base_price: Decimal
        model_coefficient: Decimal
        adjustments: AdjustmentBreakdown

        # Metadata
        brand: str
        group: str
        model_name: Optional[str]

        model_config = {"from_attributes": True}
    ```

    **3. Update `calculatePrice()` to return `PriceOutput`:**

    Return fully populated PriceOutput with all breakdown details.

    **Why this approach:**
    - Formula exactly matches ROADMAP specification
    - Detailed breakdown enables transparency (users see why price is X)
    - Quantize to 2 decimal places (currency precision)
    - All calculators from Phase 4 are used (validates full pipeline)
  </action>
  <verify>
    1. Can call `service.calculatePrice(input)` and get PriceOutput
    2. quick_price < standard_price < premium_price
    3. Breakdown shows all adjustment values
    4. Prices are Decimal with 2 decimal places
    5. No runtime errors with valid inputs
  </verify>
  <done>
    - calculatePrice() method complete with formula implementation
    - All 6 calculators integrated
    - 3 price levels calculated (quick/standard/premium)
    - PriceInput and PriceOutput schemas defined in backend/schemas/pricing.py
    - AdjustmentBreakdown schema shows all adjustment components
    - Method returns fully populated PriceOutput with breakdown
  </done>
</task>

<task type="auto">
  <name>Task 3: Write comprehensive unit tests for PricingService</name>
  <files>backend/tests/unit/services/test_pricing_service.py</files>
  <action>
    Create test file with pytest fixtures and test classes:

    **Fixtures:**
    ```python
    @pytest.fixture
    def mock_db():
        return MagicMock(spec=Session)

    @pytest.fixture
    def mock_brand_group_repo():
        return MagicMock(spec=BrandGroupRepository)

    @pytest.fixture
    def mock_model_repo():
        return MagicMock(spec=ModelRepository)

    @pytest.fixture
    def mock_generation_service():
        return MagicMock(spec=PricingGenerationService)

    @pytest.fixture
    def pricing_service(mock_db, mock_brand_group_repo, mock_model_repo, mock_generation_service):
        return PricingService(
            db=mock_db,
            brand_group_repo=mock_brand_group_repo,
            model_repo=mock_model_repo,
            generation_service=mock_generation_service
        )

    @pytest.fixture
    def sample_input():
        return PriceInput(
            brand="Nike",
            category="sneakers",
            materials=["leather"],
            model_name="Air Max 90",
            condition_score=4,
            supplements=["original_box"],
            condition_sensitivity=Decimal("1.0"),
            actual_origin="Italy",
            expected_origins=["China"],
            actual_decade="1990s",
            expected_decades=["2020s"],
            actual_trends=["vintage"],
            expected_trends=[],
            actual_features=["og_colorway"],
            expected_features=[]
        )
    ```

    **Test classes:**

    1. **TestPricingServiceDataFetching** (8-10 tests):
       - BrandGroup exists in DB → fetch only, no generation
       - BrandGroup missing → generate and save
       - Model exists in DB → fetch only
       - Model missing → generate and save
       - Group determination fails → raise ValueError
       - LLM generation fails → raise ServiceError
       - No model_name provided → model_coeff = 1.0
       - Verify DB save calls after generation

    2. **TestPricingServiceCalculation** (10-12 tests):
       - Basic calculation: base_price=100, model_coeff=1.5, no adjustments → prices correct
       - With all positive adjustments → premium > standard > quick
       - With negative adjustments → prices lower than base
       - Price levels ratios (quick=×0.75, premium=×1.30)
       - Breakdown includes all 6 adjustment values
       - Decimal precision (2 decimal places)
       - Edge case: all adjustments = 0 → standard_price = base_price × model_coeff
       - Edge case: very high adjustments → formula still applies
       - Verify all 6 calculators are called with correct inputs
       - Output schema validation (PriceOutput structure)

    3. **TestPricingServiceIntegration** (3-5 tests):
       - End-to-end: valid input → valid output with all fields
       - Different product types (sneakers, jacket, jeans) → different groups, correct calculations
       - With and without model → coefficient applied correctly

    **Total: ~25 tests**

    **Mocking strategy:**
    - Mock repositories to return known BrandGroup/Model objects
    - Mock generation_service to return predictable values
    - Don't mock calculators (test real integration with Phase 4 work)
    - Use `patch` for determineGroup if needed

    **Why comprehensive tests:**
    - PricingService is the core of the feature
    - Orchestrates 4 dependencies (repos + generation + calculators)
    - Complex formula must be validated
    - Edge cases (missing data, generation) critical for robustness
  </action>
  <verify>
    Run: `pytest backend/tests/unit/services/test_pricing_service.py -v`

    Expected:
    - All ~25 tests pass
    - Coverage >90% for PricingService
    - No warnings or errors
    - Test execution < 5 seconds (unit tests should be fast)
  </verify>
  <done>
    - test_pricing_service.py exists with 3 test classes
    - ~25 unit tests covering data fetching, calculation, integration
    - All tests pass
    - Mocked dependencies (repos, generation_service)
    - Real calculator integration (Phase 4 validation)
    - Edge cases tested (missing data, no model, generation failures)
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pytest backend/tests/unit/services/test_pricing_service.py -v` passes all tests
- [ ] PricingService can be imported without errors
- [ ] Formula matches ROADMAP specification exactly
- [ ] All 6 calculators are integrated and called
- [ ] 3 price levels calculated correctly (quick < standard < premium)
- [ ] Detailed breakdown included in PriceOutput
</verification>

<success_criteria>

- All tasks completed
- PricingService fully implemented in backend/services/pricing_service.py
- PriceInput and PriceOutput schemas defined
- ~25 unit tests passing
- No errors or warnings
- Ready for API endpoint integration (Plan 05-02)
</success_criteria>

<output>
After completion, create `.planning/phases/05-main-pricing-algorithm/05-01-SUMMARY.md`:

# Phase 5 Plan 1: Core Pricing Service Summary

**[Substantive one-liner describing the pricing engine implementation]**

## Accomplishments

- PricingService orchestrates all 6 calculators
- Data fetching with automatic LLM generation fallback
- Formula: PRICE = BASE_PRICE × MODEL_COEFF × (1 + ADJUSTMENTS)
- 3 price levels: quick (×0.75), standard (×1.0), premium (×1.30)
- Detailed breakdown with all adjustment values

## Files Created/Modified

- `backend/services/pricing_service.py` - Core pricing engine
- `backend/schemas/pricing.py` - PriceInput, PriceOutput, AdjustmentBreakdown schemas
- `backend/tests/unit/services/test_pricing_service.py` - Comprehensive unit tests (~25 tests)

## Decisions Made

- Service layer pattern (Clean Architecture)
- Fetch-or-generate strategy for BrandGroup & Model (cache in DB)
- Mocked dependencies in tests, real calculators (validates Phase 4 integration)

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 05-02-PLAN.md (API Endpoint & Integration)
</output>
