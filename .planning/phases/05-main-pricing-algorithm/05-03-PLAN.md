---
phase: 05-main-pricing-algorithm
plan: 03
type: execute
---

<objective>
Polish error handling, add comprehensive logging, and ensure production readiness.

Purpose: Add robust error handling for edge cases (missing data, LLM failures, DB errors), implement detailed logging for debugging and monitoring, and validate the complete pricing system is production-ready.

Output: Production-grade error handling and logging system with monitoring capabilities.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-phase.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-main-pricing-algorithm/05-01-SUMMARY.md
@.planning/phases/05-main-pricing-algorithm/05-02-SUMMARY.md

**Phase dependencies:**
- Plan 05-01: PricingService implementation complete
- Plan 05-02: API endpoint with integration tests complete

**Error scenarios to handle:**
- BrandGroup/Model generation failures (LLM timeout, invalid response)
- Group determination failures (invalid category/materials)
- Database errors (connection loss, constraint violations)
- Missing required data (brand, category, etc.)
- Invalid adjustment inputs (out-of-range scores, unknown origins)
- Edge cases (extreme prices, negative adjustments, overflow)

**Logging requirements:**
- Request/response logging (input/output prices)
- LLM generation attempts (success/failure, latency)
- Database operations (fetch/generate, query times)
- Calculator results (breakdown of each adjustment)
- Error details (stack traces, context)
- Performance metrics (total time, component times)

**Production concerns:**
- Graceful degradation (fallback to cached data)
- Rate limiting for LLM calls
- Timeout handling (max 10s total, 5s per LLM call)
- Input validation at API boundary
- Clear error messages for users
- Monitoring alerts for failures
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add comprehensive error handling to PricingService</name>
  <files>backend/services/pricing_service.py, backend/shared/exceptions.py</files>
  <action>
    **1. Define custom exceptions in `backend/shared/exceptions.py`:**

    ```python
    class PricingError(ServiceError):
        """Base exception for pricing-related errors."""
        pass

    class GroupDeterminationError(PricingError):
        """Raised when group cannot be determined from category/materials."""
        def __init__(self, category: str, materials: list[str]):
            self.category = category
            self.materials = materials
            super().__init__(f"Cannot determine group for category '{category}' with materials {materials}")

    class BrandGroupGenerationError(PricingError):
        """Raised when BrandGroup generation fails after retries."""
        def __init__(self, brand: str, group: str, reason: str):
            self.brand = brand
            self.group = group
            super().__init__(f"Failed to generate BrandGroup for {brand}/{group}: {reason}")

    class ModelGenerationError(PricingError):
        """Raised when Model generation fails after retries."""
        def __init__(self, brand: str, group: str, model: str, reason: str):
            self.brand = brand
            self.group = group
            self.model = model
            super().__init__(f"Failed to generate Model for {brand}/{group}/{model}: {reason}")

    class PricingCalculationError(PricingError):
        """Raised when price calculation fails."""
        pass
    ```

    **2. Update PricingService.calculatePrice() with error handling:**

    ```python
    import logging
    from decimal import Decimal, InvalidOperation
    from typing import Optional

    logger = logging.getLogger(__name__)

    class PricingService:
        # ... existing code ...

        def calculatePrice(self, input: PriceInput) -> PriceOutput:
            """
            Calculate product price with comprehensive error handling.

            Raises:
                GroupDeterminationError: If group cannot be determined
                BrandGroupGenerationError: If BrandGroup generation fails
                ModelGenerationError: If Model generation fails
                PricingCalculationError: If calculation fails
            """
            try:
                # 1. Determine group
                try:
                    group = determineGroup(input.category, input.materials)
                except ValueError as e:
                    logger.error(f"Group determination failed: {e}", extra={
                        "category": input.category,
                        "materials": input.materials
                    })
                    raise GroupDeterminationError(input.category, input.materials) from e

                # 2. Fetch/generate BrandGroup
                brand_group = self.brand_group_repo.get_by_brand_and_group(input.brand, group)
                if not brand_group:
                    logger.info(f"BrandGroup not found, generating: {input.brand}/{group}")
                    try:
                        brand_group = self.generation_service.generateBrandGroup(input.brand, group)
                        self.brand_group_repo.save(brand_group)
                        self.db.commit()
                        logger.info(f"BrandGroup generated successfully: {input.brand}/{group}", extra={
                            "base_price": str(brand_group.base_price)
                        })
                    except Exception as e:
                        self.db.rollback()
                        logger.error(f"BrandGroup generation failed: {e}", exc_info=True, extra={
                            "brand": input.brand,
                            "group": group
                        })
                        raise BrandGroupGenerationError(input.brand, group, str(e)) from e

                base_price = brand_group.base_price

                # 3. Fetch/generate Model if provided
                model_coeff = Decimal("1.0")
                model = None
                if input.model_name:
                    model = self.model_repo.get_by_brand_group_and_model(brand_group.id, input.model_name)
                    if not model:
                        logger.info(f"Model not found, generating: {input.brand}/{group}/{input.model_name}")
                        try:
                            model = self.generation_service.generateModel(
                                input.brand, group, input.model_name, base_price
                            )
                            self.model_repo.save(model)
                            self.db.commit()
                            logger.info(f"Model generated successfully: {input.model_name}", extra={
                                "coefficient": str(model.coefficient)
                            })
                        except Exception as e:
                            self.db.rollback()
                            logger.error(f"Model generation failed: {e}", exc_info=True, extra={
                                "brand": input.brand,
                                "group": group,
                                "model": input.model_name
                            })
                            raise ModelGenerationError(input.brand, group, input.model_name, str(e)) from e

                    model_coeff = calculateModelCoefficient(model)

                # 4. Calculate adjustments with error handling
                try:
                    condition_adj = calculateConditionAdjustment(
                        input.condition_score, input.supplements, input.condition_sensitivity
                    )
                    origin_adj = calculateOriginAdjustment(input.actual_origin, input.expected_origins)
                    decade_adj = calculateDecadeAdjustment(input.actual_decade, input.expected_decades)
                    trend_adj = calculateTrendAdjustment(input.actual_trends, input.expected_trends)
                    feature_adj = calculateFeatureAdjustment(input.actual_features, input.expected_features)
                except (ValueError, KeyError, InvalidOperation) as e:
                    logger.error(f"Adjustment calculation failed: {e}", exc_info=True, extra={
                        "input": input.model_dump()
                    })
                    raise PricingCalculationError(f"Failed to calculate adjustments: {str(e)}") from e

                # 5. Calculate prices
                try:
                    total_adjustment = condition_adj + origin_adj + decade_adj + trend_adj + feature_adj
                    adjusted_price = base_price * model_coeff * (1 + total_adjustment)

                    quick_price = (adjusted_price * Decimal("0.75")).quantize(Decimal("0.01"))
                    standard_price = adjusted_price.quantize(Decimal("0.01"))
                    premium_price = (adjusted_price * Decimal("1.30")).quantize(Decimal("0.01"))
                except (InvalidOperation, OverflowError) as e:
                    logger.error(f"Price calculation failed: {e}", exc_info=True, extra={
                        "base_price": str(base_price),
                        "model_coeff": str(model_coeff),
                        "total_adjustment": str(total_adjustment)
                    })
                    raise PricingCalculationError(f"Failed to calculate final prices: {str(e)}") from e

                # 6. Build output
                logger.info("Price calculation successful", extra={
                    "brand": input.brand,
                    "group": group,
                    "model": input.model_name,
                    "quick_price": str(quick_price),
                    "standard_price": str(standard_price),
                    "premium_price": str(premium_price)
                })

                return PriceOutput(
                    quick_price=quick_price,
                    standard_price=standard_price,
                    premium_price=premium_price,
                    base_price=base_price,
                    model_coefficient=model_coeff,
                    adjustments=AdjustmentBreakdown(
                        condition=condition_adj,
                        origin=origin_adj,
                        decade=decade_adj,
                        trend=trend_adj,
                        feature=feature_adj,
                        total=total_adjustment
                    ),
                    brand=input.brand,
                    group=group,
                    model_name=input.model_name
                )

            except PricingError:
                # Re-raise our custom exceptions
                raise
            except Exception as e:
                # Catch any unexpected errors
                logger.error(f"Unexpected error in calculatePrice: {e}", exc_info=True, extra={
                    "input": input.model_dump()
                })
                raise PricingCalculationError(f"Unexpected error during price calculation: {str(e)}") from e
    ```

    **Why this approach:**
    - Custom exceptions with context (brand, group, model, reason)
    - Granular error handling at each step
    - Database rollback on generation failures
    - Comprehensive logging with structured context
    - Re-raise custom exceptions, wrap unexpected ones
    - Clear error messages for debugging
  </action>
  <verify>
    1. Can import all custom exceptions
    2. PricingService raises appropriate exceptions for each failure scenario
    3. Logs include structured context (extra fields)
    4. Database rollback works correctly on generation failures
    5. No syntax or type errors
  </verify>
  <done>
    - Custom exceptions defined in backend/shared/exceptions.py
    - PricingService.calculatePrice() has comprehensive error handling
    - Try/except blocks for each step (group, BrandGroup, Model, adjustments, prices)
    - Database rollback on generation failures
    - Structured logging with context
    - Clear error messages with details
  </done>
</task>

<task type="auto">
  <name>Task 2: Update API endpoint with error mapping and performance logging</name>
  <files>backend/api/pricing.py</files>
  <action>
    Update `backend/api/pricing.py` to map exceptions to HTTP status codes and add performance logging:

    ```python
    import logging
    import time
    from fastapi import APIRouter, Depends, status, HTTPException
    from sqlalchemy.orm import Session

    from models.public.user import User
    from schemas.pricing import PriceInput, PriceOutput
    from services.pricing_service import PricingService
    from services.pricing_generation_service import PricingGenerationService
    from repositories.brand_group_repository import BrandGroupRepository
    from repositories.model_repository import ModelRepository
    from shared.dependencies import get_user_db, get_current_user
    from shared.exceptions import (
        GroupDeterminationError,
        BrandGroupGenerationError,
        ModelGenerationError,
        PricingCalculationError
    )

    router = APIRouter(prefix="/api/pricing", tags=["pricing"])
    logger = logging.getLogger(__name__)

    @router.post(
        "/calculate",
        response_model=PriceOutput,
        status_code=status.HTTP_200_OK,
        summary="Calculate product price with 3 levels",
        description="Orchestrates all pricing calculators to generate quick/standard/premium prices with detailed breakdown"
    )
    def calculate_price(
        input: PriceInput,
        db_user: tuple[Session, User] = Depends(get_user_db),
        current_user: User = Depends(get_current_user)
    ) -> PriceOutput:
        """
        Calculate product price using pricing algorithm.

        Fetches/generates BrandGroup and Model data, applies all 6 adjustment calculators,
        returns 3 price levels (quick/standard/premium) with detailed breakdown.

        Args:
            input: PriceInput with product attributes and adjustment parameters
            db_user: Database session with user schema set
            current_user: Authenticated user

        Returns:
            PriceOutput with 3 price levels and adjustment breakdown

        Raises:
            HTTPException 400: Invalid input data or group determination failure
            HTTPException 500: Service error (LLM failure, DB error)
            HTTPException 504: Timeout during LLM generation
        """
        db, user = db_user
        start_time = time.time()

        logger.info("Pricing calculation request", extra={
            "user_id": user.id,
            "brand": input.brand,
            "category": input.category,
            "model": input.model_name
        })

        # Initialize dependencies
        brand_group_repo = BrandGroupRepository(db)
        model_repo = ModelRepository(db)
        generation_service = PricingGenerationService(db)

        # Create pricing service
        pricing_service = PricingService(
            db=db,
            brand_group_repo=brand_group_repo,
            model_repo=model_repo,
            generation_service=generation_service
        )

        try:
            # Calculate price
            result = pricing_service.calculatePrice(input)

            # Log success with performance metrics
            elapsed_time = time.time() - start_time
            logger.info("Pricing calculation successful", extra={
                "user_id": user.id,
                "brand": input.brand,
                "elapsed_time_ms": round(elapsed_time * 1000, 2),
                "standard_price": str(result.standard_price)
            })

            return result

        except GroupDeterminationError as e:
            # Invalid category/materials combination
            elapsed_time = time.time() - start_time
            logger.warning(f"Group determination failed: {e}", extra={
                "user_id": user.id,
                "category": e.category,
                "materials": e.materials,
                "elapsed_time_ms": round(elapsed_time * 1000, 2)
            })
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Cannot determine product group: {str(e)}"
            )

        except (BrandGroupGenerationError, ModelGenerationError) as e:
            # LLM generation failures
            elapsed_time = time.time() - start_time
            logger.error(f"Generation failed: {e}", extra={
                "user_id": user.id,
                "elapsed_time_ms": round(elapsed_time * 1000, 2)
            })

            # Check if timeout
            if "timeout" in str(e).lower() or elapsed_time > 10:
                raise HTTPException(
                    status_code=status.HTTP_504_GATEWAY_TIMEOUT,
                    detail="Price calculation timed out. Please try again."
                )

            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Failed to generate pricing data: {str(e)}"
            )

        except PricingCalculationError as e:
            # Calculation errors (adjustment or price calculation)
            elapsed_time = time.time() - start_time
            logger.error(f"Calculation failed: {e}", extra={
                "user_id": user.id,
                "elapsed_time_ms": round(elapsed_time * 1000, 2)
            })
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Price calculation failed: {str(e)}"
            )

        except Exception as e:
            # Unexpected errors
            elapsed_time = time.time() - start_time
            logger.error(f"Unexpected error in calculate_price: {e}", exc_info=True, extra={
                "user_id": user.id,
                "elapsed_time_ms": round(elapsed_time * 1000, 2)
            })
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="An unexpected error occurred during price calculation"
            )
    ```

    **Why this approach:**
    - Performance logging (request start/end times)
    - Granular error mapping (400 for validation, 500 for generation, 504 for timeout)
    - Structured logging with user context
    - Clear user-facing error messages
    - Stack traces logged for unexpected errors
    - Monitoring-friendly (structured logs, metrics)
  </action>
  <verify>
    1. API returns correct HTTP status codes for each error type
    2. Error messages are clear and actionable
    3. Performance metrics logged for all requests
    4. Logs include user context (user_id)
    5. No sensitive data in error responses
    6. OpenAPI docs updated with new error responses
  </verify>
  <done>
    - API endpoint updated with granular error handling
    - Exception mapping: 400 (validation), 500 (generation), 504 (timeout)
    - Performance logging (elapsed time in ms)
    - Structured logging with user context
    - Clear error messages for users
    - Stack traces logged for debugging
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All custom exceptions defined and importable
- [ ] PricingService has comprehensive error handling at each step
- [ ] Database rollback works on generation failures
- [ ] API endpoint maps exceptions to correct HTTP status codes
- [ ] Structured logging includes context (user_id, brand, elapsed_time)
- [ ] Error messages are clear and helpful
- [ ] No sensitive data leaked in error responses
- [ ] All integration tests still pass
</verification>

<success_criteria>

- All tasks completed
- Custom exceptions with context defined
- PricingService has robust error handling
- API endpoint has granular error mapping
- Performance logging implemented
- Clear error messages for users
- Production-ready error handling
- Ready for Phase 6 (Frontend UI)
</success_criteria>

<output>
After completion, create `.planning/phases/05-main-pricing-algorithm/05-03-SUMMARY.md`:

# Phase 5 Plan 3: Error Handling & Polish Summary

**[Substantive one-liner describing the error handling and logging implementation]**

## Accomplishments

- Custom exceptions with context (brand, group, model, reason)
- Comprehensive error handling in PricingService (group, generation, calculation)
- Database rollback on generation failures
- Granular error mapping in API (400/500/504)
- Performance logging (elapsed time metrics)
- Structured logging with context

## Files Created/Modified

- `backend/shared/exceptions.py` - Custom pricing exceptions
- `backend/services/pricing_service.py` - Error handling at each step
- `backend/api/pricing.py` - HTTP error mapping and performance logging

## Decisions Made

- Custom exceptions for each failure type (group, BrandGroup, Model, calculation)
- Database rollback on generation failures (prevent partial data)
- Timeout detection (>10s or "timeout" in error message)
- Structured logging with extra fields (user_id, brand, elapsed_time_ms)
- User-facing error messages without stack traces

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Phase 5 complete! Ready for Phase 6 (Frontend UI)
</output>
