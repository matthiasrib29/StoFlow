---
phase: 04-adjustment-calculators
plan: 03
type: tdd
---

<objective>
Implement Trend and Feature Adjustment calculators using TDD.

Purpose: Complete the adjustment calculator suite with list-based comparison logic. Trend calculator finds the best unexpected trend bonus, Feature calculator sums unexpected features. These are the final two calculators needed for the pricing algorithm.

Output: Two fully tested calculator functions completing the Phase 4 adjustment calculator suite.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-phase.md
@./.claude/get-shit-done/templates/summary.md
@./.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-adjustment-calculators/04-01-SUMMARY.md
@.planning/phases/04-adjustment-calculators/04-02-SUMMARY.md

**Dependencies:**
- Plan 1: Basic calculator patterns (Model, Condition)
- Plan 2: Tier and coefficient dictionary patterns (Origin, Decade)
- Established: SUPPLEMENT_VALUES, DECADE_COEFFICIENTS patterns

**Formulas specified in ROADMAP:**

1. **Trend Adjustment** (best unexpected):
   - Input: actual_trends (list[str]), expected_trends (list[str])
   - Output: Decimal adjustment (0.00 to +0.20)
   - Logic:
     - Find trends in actual_trends that are NOT in expected_trends
     - For each unexpected trend, get coefficient from TREND_COEFFICIENTS
     - Return the MAXIMUM coefficient (best unexpected trend)
     - If no unexpected trends or all actual are expected → 0.00
   - TREND_COEFFICIENTS: {"y2k": 0.20, "vintage": 0.18, "grunge": 0.15, "streetwear": 0.12, "minimalist": 0.08, "bohemian": 0.06, "preppy": 0.04, "athleisure": 0.02}

2. **Feature Adjustment** (sum unexpected):
   - Input: actual_features (list[str]), expected_features (list[str])
   - Output: Decimal adjustment (0.00 to +0.30, capped)
   - Logic:
     - Find features in actual_features that are NOT in expected_features
     - For each unexpected feature, get coefficient from FEATURE_COEFFICIENTS
     - Return the SUM of coefficients, capped at +0.30
     - If no unexpected features or all actual are expected → 0.00
   - FEATURE_COEFFICIENTS: {"selvedge": 0.15, "original_box": 0.10, "limited_edition": 0.12, "deadstock": 0.20, "chain_stitching": 0.08, "vintage_label": 0.10, "og_colorway": 0.15}
</context>

<feature>
  <name>calculateTrendAdjustment</name>
  <files>
    - backend/services/pricing/adjustment_calculators.py (extend)
    - backend/tests/unit/services/pricing/test_adjustment_calculators.py (extend)
  </files>
  <behavior>
    Best unexpected trend bonus (max, not sum).

    All expected cases (no bonus):
    - actual=["y2k"], expected=["y2k"] → 0.00
    - actual=["y2k", "vintage"], expected=["y2k", "vintage"] → 0.00
    - actual=[], expected=["vintage"] → 0.00 (no actual trends)

    Single unexpected trend cases:
    - actual=["y2k"], expected=["vintage"] → +0.20 (y2k is unexpected)
    - actual=["vintage"], expected=["grunge"] → +0.18
    - actual=["streetwear"], expected=["minimalist"] → +0.12

    Multiple unexpected trends (max, not sum):
    - actual=["y2k", "vintage"], expected=["grunge"] → +0.20 (max of 0.20, 0.18)
    - actual=["streetwear", "minimalist"], expected=["y2k"] → +0.12 (max of 0.12, 0.08)
    - actual=["y2k", "vintage", "grunge"], expected=[] → +0.20 (max of all)

    Mixed expected/unexpected cases:
    - actual=["y2k", "vintage"], expected=["y2k"] → +0.18 (vintage unexpected)
    - actual=["grunge", "streetwear"], expected=["grunge"] → +0.12 (streetwear unexpected)

    Edge cases:
    - actual=[], expected=[] → 0.00
    - actual with unknown trends → Should ignore unknown trends or raise ValueError
    - expected with unknown trends → Should still work (just won't match)
  </behavior>
  <implementation>
    Add to `backend/services/pricing/adjustment_calculators.py`:
    - Function signature: `def calculateTrendAdjustment(actual_trends: list[str], expected_trends: list[str]) -> Decimal`
    - Constants dict: TREND_COEFFICIENTS = {"y2k": Decimal("0.20"), "vintage": Decimal("0.18"), "grunge": Decimal("0.15"), "streetwear": Decimal("0.12"), "minimalist": Decimal("0.08"), "bohemian": Decimal("0.06"), "preppy": Decimal("0.04"), "athleisure": Decimal("0.02")}
    - Logic:
      - unexpected_trends = [t for t in actual_trends if t not in expected_trends and t in TREND_COEFFICIENTS]
      - If empty unexpected_trends → return Decimal("0.00")
      - Else → return max([TREND_COEFFICIENTS[t] for t in unexpected_trends])
    - Validation: actual_trends and expected_trends can be empty (valid case)
    - Unknown trends in actual_trends: ignore them (don't crash)
    - Return: Decimal adjustment (0.00 to +0.20)
  </implementation>
</feature>

<feature>
  <name>calculateFeatureAdjustment</name>
  <files>
    - backend/services/pricing/adjustment_calculators.py (extend)
    - backend/tests/unit/services/pricing/test_adjustment_calculators.py (extend)
  </files>
  <behavior>
    Sum unexpected features with +0.30 cap.

    All expected cases (no bonus):
    - actual=["selvedge"], expected=["selvedge"] → 0.00
    - actual=["selvedge", "original_box"], expected=["selvedge", "original_box"] → 0.00
    - actual=[], expected=["selvedge"] → 0.00 (no actual features)

    Single unexpected feature cases:
    - actual=["deadstock"], expected=["selvedge"] → +0.20
    - actual=["selvedge"], expected=["original_box"] → +0.15
    - actual=["original_box"], expected=["selvedge"] → +0.10

    Multiple unexpected features (sum):
    - actual=["selvedge", "original_box"], expected=["deadstock"] → +0.25 (0.15 + 0.10)
    - actual=["chain_stitching", "vintage_label"], expected=[] → +0.18 (0.08 + 0.10)

    Capping cases (sum > 0.30):
    - actual=["deadstock", "selvedge"], expected=[] → +0.30 (cap 0.20 + 0.15 = 0.35)
    - actual=["deadstock", "og_colorway"], expected=[] → +0.30 (cap 0.20 + 0.15 = 0.35)
    - actual=["selvedge", "limited_edition", "vintage_label"], expected=[] → +0.30 (cap 0.15 + 0.12 + 0.10 = 0.37)

    Mixed expected/unexpected cases:
    - actual=["selvedge", "original_box"], expected=["selvedge"] → +0.10 (original_box unexpected)
    - actual=["deadstock", "selvedge"], expected=["deadstock"] → +0.15 (selvedge unexpected)

    Edge cases:
    - actual=[], expected=[] → 0.00
    - actual with unknown features → Should ignore unknown features
    - expected with unknown features → Should still work
  </behavior>
  <implementation>
    Add to `backend/services/pricing/adjustment_calculators.py`:
    - Function signature: `def calculateFeatureAdjustment(actual_features: list[str], expected_features: list[str]) -> Decimal`
    - Constants dict: FEATURE_COEFFICIENTS = {"selvedge": Decimal("0.15"), "original_box": Decimal("0.10"), "limited_edition": Decimal("0.12"), "deadstock": Decimal("0.20"), "chain_stitching": Decimal("0.08"), "vintage_label": Decimal("0.10"), "og_colorway": Decimal("0.15")}
    - Logic:
      - unexpected_features = [f for f in actual_features if f not in expected_features and f in FEATURE_COEFFICIENTS]
      - If empty unexpected_features → return Decimal("0.00")
      - Else → sum_value = sum([FEATURE_COEFFICIENTS[f] for f in unexpected_features])
      - Return min(sum_value, Decimal("0.30")) (cap at +0.30)
    - Validation: actual_features and expected_features can be empty (valid case)
    - Unknown features in actual_features: ignore them (don't crash)
    - Return: Decimal adjustment (0.00 to +0.30)
  </implementation>
</feature>

<verification>
All tests pass:
```bash
pytest backend/tests/unit/services/pricing/test_adjustment_calculators.py::TestCalculateTrendAdjustment -v
pytest backend/tests/unit/services/pricing/test_adjustment_calculators.py::TestCalculateFeatureAdjustment -v
```

All 6 calculators work together:
```bash
pytest backend/tests/unit/services/pricing/test_adjustment_calculators.py -v
```

Expected test classes:
- TestCalculateTrendAdjustment (12-15 tests covering max logic)
- TestCalculateFeatureAdjustment (12-15 tests covering sum + cap logic)

Total for phase: 6 test classes, ~70-80 tests total
</verification>

<success_criteria>
- RED phase: Failing tests written for both calculators
- GREEN phase: Implementation passes all tests
- REFACTOR phase: Code cleaned if needed (optional)
- All tests pass (including all previous calculators from Plan 1 & 2)
- Phase 4 complete: All 6 calculators implemented and tested
- Code committed with TDD commit pattern (test → feat → refactor)
- Trend correctly returns MAX (not sum)
- Feature correctly returns SUM with cap at +0.30
</success_criteria>

<output>
After completion, create `.planning/phases/04-adjustment-calculators/04-03-SUMMARY.md`:

# Phase 4 Plan 3: Trend & Feature Adjustment Summary

**TDD implementation of list-based trend and feature adjustment calculators, completing the Phase 4 calculator suite**

## TDD Cycle

### RED Phase
- Tests written for calculateTrendAdjustment (12-15 tests)
- Tests written for calculateFeatureAdjustment (12-15 tests)
- All tests initially failing

### GREEN Phase
- calculateTrendAdjustment implemented (max unexpected trend)
- calculateFeatureAdjustment implemented (sum unexpected features with cap)
- All tests passing

### REFACTOR Phase
- [If any refactoring done, describe it]
- [Or: "No refactoring needed - implementation clean"]

## Commits
- `test(04-03): add failing tests for trend adjustment calculator` - [hash]
- `feat(04-03): implement calculateTrendAdjustment with max logic` - [hash]
- `test(04-03): add failing tests for feature adjustment calculator` - [hash]
- `feat(04-03): implement calculateFeatureAdjustment with sum and cap` - [hash]
- [Optional] `refactor(04-03): [description]` - [hash]

## Files Created/Modified
- `backend/services/pricing/adjustment_calculators.py` - Extended with final 2 calculators
- `backend/tests/unit/services/pricing/test_adjustment_calculators.py` - Extended test suite

## Phase 4 Complete
All 6 adjustment calculators implemented:
1. ✅ calculateModelCoefficient (Plan 1)
2. ✅ calculateConditionAdjustment (Plan 1)
3. ✅ calculateOriginAdjustment (Plan 2)
4. ✅ calculateDecadeAdjustment (Plan 2)
5. ✅ calculateTrendAdjustment (Plan 3)
6. ✅ calculateFeatureAdjustment (Plan 3)

Total: ~70-80 tests, 100% passing

## Next Phase
Ready for Phase 5: Main Pricing Algorithm & API
</output>
