---
phase: 04-adjustment-calculators
plan: 02
type: tdd
---

<objective>
Implement Origin and Decade Adjustment calculators using TDD.

Purpose: Create tier-based and temporal adjustment calculators. Origin uses a tier system (expected/neighbor/other), decade provides bonuses for unexpected eras. These introduce more complex comparison logic than Plan 1.

Output: Two fully tested calculator functions with comprehensive tier/decade coverage.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-phase.md
@./.claude/get-shit-done/templates/summary.md
@./.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-adjustment-calculators/04-01-SUMMARY.md

**Dependencies:**
- Plan 1: Calculator patterns and test structure established
- SUPPLEMENT_VALUES pattern can be reused for DECADE_COEFFICIENTS

**Formulas specified in ROADMAP:**

1. **Origin Adjustment** (tier-based):
   - Input: actual_origin (str), expected_origins (list[str])
   - Output: Decimal adjustment (-0.10 to +0.15)
   - Tier logic:
     - Tier 1 (expected): actual in expected_origins → 0.00
     - Tier 2 (neighbor): actual in neighboring countries → 0.00
     - Tier 3 (premium): actual in premium origins → +0.15
     - Tier 4 (other): fallback → -0.10
   - ORIGIN_TIERS constant needed with country mappings

2. **Decade Adjustment** (temporal bonus):
   - Input: actual_decade (str, e.g., "1990s"), expected_decades (list[str])
   - Output: Decimal adjustment (0.00 to +0.20)
   - Logic:
     - If actual in expected_decades → 0.00 (as expected, no bonus)
     - If actual NOT in expected_decades → bonus from DECADE_COEFFICIENTS
   - DECADE_COEFFICIENTS: {"1950s": 0.20, "1960s": 0.18, "1970s": 0.15, "1980s": 0.12, "1990s": 0.08, "2000s": 0.05, "2010s": 0.02, "2020s": 0.00}
</context>

<feature>
  <name>calculateOriginAdjustment</name>
  <files>
    - backend/services/pricing/adjustment_calculators.py (extend)
    - backend/tests/unit/services/pricing/test_adjustment_calculators.py (extend)
  </files>
  <behavior>
    Tier-based country comparison with neighbor detection.

    Tier 1 (expected) cases:
    - actual="France", expected=["France", "Italy"] → 0.00
    - actual="Italy", expected=["France", "Italy"] → 0.00

    Tier 2 (neighbor) cases:
    - actual="Belgium", expected=["France"] (Belgium neighbors France) → 0.00
    - actual="Switzerland", expected=["Italy"] (Switzerland neighbors Italy) → 0.00

    Tier 3 (premium) cases:
    - actual="Italy", expected=["China"] (Italy is premium origin) → +0.15
    - actual="France", expected=["Turkey"] (France is premium origin) → +0.15
    - actual="Japan", expected=["China"] (Japan is premium origin) → +0.15

    Tier 4 (other) cases:
    - actual="China", expected=["Italy"] (China not premium, not neighbor) → -0.10
    - actual="Turkey", expected=["France"] (Turkey not premium, not neighbor) → -0.10

    Edge cases:
    - Empty expected_origins → Should use tier logic normally (no Tier 1 match)
    - actual_origin is None or empty → Should raise ValueError
    - Unknown country → Should fallback to Tier 4 (-0.10)
  </behavior>
  <implementation>
    Add to `backend/services/pricing/adjustment_calculators.py`:
    - Function signature: `def calculateOriginAdjustment(actual_origin: str, expected_origins: list[str]) -> Decimal`
    - Constants:
      - PREMIUM_ORIGINS = {"Italy", "France", "Japan", "USA", "UK", "Germany"}
      - COUNTRY_NEIGHBORS = {"France": {"Belgium", "Switzerland", "Spain", "Italy", "Germany"}, "Italy": {"France", "Switzerland", "Austria"}, ...} (key countries only)
    - Tier 1: if actual in expected_origins → 0.00
    - Tier 3: elif actual in PREMIUM_ORIGINS and actual not in expected_origins → +0.15
    - Tier 2: elif any neighbor of expected is actual → 0.00
    - Tier 4: else → -0.10
    - Validation: raise ValueError if actual_origin is None or empty
    - Return: Decimal adjustment
  </implementation>
</feature>

<feature>
  <name>calculateDecadeAdjustment</name>
  <files>
    - backend/services/pricing/adjustment_calculators.py (extend)
    - backend/tests/unit/services/pricing/test_adjustment_calculators.py (extend)
  </files>
  <behavior>
    Temporal bonus for unexpected decades.

    Expected decade cases (no bonus):
    - actual="1990s", expected=["1990s", "2000s"] → 0.00
    - actual="2010s", expected=["2010s"] → 0.00

    Unexpected decade cases (bonus):
    - actual="1950s", expected=["2000s"] → +0.20 (vintage premium)
    - actual="1960s", expected=["2000s"] → +0.18
    - actual="1970s", expected=["2000s"] → +0.15
    - actual="1980s", expected=["2000s"] → +0.12
    - actual="1990s", expected=["2000s"] → +0.08
    - actual="2000s", expected=["2010s"] → +0.05
    - actual="2010s", expected=["2020s"] → +0.02
    - actual="2020s", expected=["1990s"] → 0.00 (modern, no vintage value)

    Edge cases:
    - Empty expected_decades → All decades become unexpected (bonus applied)
    - actual_decade is None or empty → Should raise ValueError
    - Unknown decade format → Should raise ValueError
    - actual_decade not in DECADE_COEFFICIENTS → Should raise ValueError
  </behavior>
  <implementation>
    Add to `backend/services/pricing/adjustment_calculators.py`:
    - Function signature: `def calculateDecadeAdjustment(actual_decade: str, expected_decades: list[str]) -> Decimal`
    - Constants dict: DECADE_COEFFICIENTS = {"1950s": Decimal("0.20"), "1960s": Decimal("0.18"), "1970s": Decimal("0.15"), "1980s": Decimal("0.12"), "1990s": Decimal("0.08"), "2000s": Decimal("0.05"), "2010s": Decimal("0.02"), "2020s": Decimal("0.00")}
    - Logic:
      - If actual in expected_decades → return Decimal("0.00")
      - Else if actual in DECADE_COEFFICIENTS → return DECADE_COEFFICIENTS[actual]
      - Else → raise ValueError
    - Validation: raise ValueError if actual_decade is None, empty, or not in DECADE_COEFFICIENTS
    - Return: Decimal adjustment (0.00 to +0.20)
  </implementation>
</feature>

<verification>
All tests pass:
```bash
pytest backend/tests/unit/services/pricing/test_adjustment_calculators.py::TestCalculateOriginAdjustment -v
pytest backend/tests/unit/services/pricing/test_adjustment_calculators.py::TestCalculateDecadeAdjustment -v
```

Expected test classes:
- TestCalculateOriginAdjustment (12-15 tests covering all tiers)
- TestCalculateDecadeAdjustment (10-12 tests covering all decades)
</verification>

<success_criteria>
- RED phase: Failing tests written for both calculators
- GREEN phase: Implementation passes all tests
- REFACTOR phase: Code cleaned if needed (optional)
- All tests pass
- Code committed with TDD commit pattern (test → feat → refactor)
- Tier logic correctly handles all 4 origin tiers
- Decade logic correctly differentiates expected vs unexpected
</success_criteria>

<output>
After completion, create `.planning/phases/04-adjustment-calculators/04-02-SUMMARY.md`:

# Phase 4 Plan 2: Origin & Decade Adjustment Summary

**TDD implementation of tier-based origin and temporal decade adjustment calculators**

## TDD Cycle

### RED Phase
- Tests written for calculateOriginAdjustment (12-15 tests)
- Tests written for calculateDecadeAdjustment (10-12 tests)
- All tests initially failing

### GREEN Phase
- calculateOriginAdjustment implemented (4-tier system)
- calculateDecadeAdjustment implemented (temporal bonuses)
- All tests passing

### REFACTOR Phase
- [If any refactoring done, describe it]
- [Or: "No refactoring needed - implementation clean"]

## Commits
- `test(04-02): add failing tests for origin adjustment calculator` - [hash]
- `feat(04-02): implement calculateOriginAdjustment with tier system` - [hash]
- `test(04-02): add failing tests for decade adjustment calculator` - [hash]
- `feat(04-02): implement calculateDecadeAdjustment with vintage bonuses` - [hash]
- [Optional] `refactor(04-02): [description]` - [hash]

## Files Created/Modified
- `backend/services/pricing/adjustment_calculators.py` - Extended with 2 calculators
- `backend/tests/unit/services/pricing/test_adjustment_calculators.py` - Extended test suite

## Next Step
Ready for 04-03-PLAN.md (Trend & Feature Adjustments)
</output>
