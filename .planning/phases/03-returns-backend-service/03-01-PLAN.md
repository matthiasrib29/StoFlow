# Plan 03-01: Returns Backend Service

## Context

Phase 3 implements the service layer for eBay returns management.
Builds on Phase 2 (EbayReturnClient, EbayReturn model).

**Service Layer Responsibilities**:
- EbayReturnService: Business logic for return operations
- EbayReturnSyncService: Synchronize returns from eBay to local DB
- EbayReturnRepository: Data access layer

**Patterns from existing services** (ebay_order_sync_service.py, ebay_order_fulfillment_service.py):
- Repository pattern for DB access
- Service orchestrates client + repository
- Sync service handles eBay → DB synchronization
- Detailed statistics return on sync operations

## Tasks

### Task 1: Create EbayReturnRepository

**Goal**: Create repository for EbayReturn data access (CRUD + queries).

**Files to create**:
- `backend/repositories/ebay_return_repository.py`

**Implementation**:

```python
class EbayReturnRepository:
    """Repository for EbayReturn CRUD and queries."""

    # CRUD
    @staticmethod
    def create(db: Session, return_: EbayReturn) -> EbayReturn

    @staticmethod
    def get_by_id(db: Session, return_id: int) -> Optional[EbayReturn]

    @staticmethod
    def get_by_ebay_return_id(db: Session, ebay_return_id: str) -> Optional[EbayReturn]

    @staticmethod
    def update(db: Session, return_: EbayReturn) -> EbayReturn

    # Queries
    @staticmethod
    def list_returns(
        db: Session,
        skip: int = 0,
        limit: int = 50,
        state: Optional[str] = None,
        status: Optional[str] = None,
        order_id: Optional[str] = None,
    ) -> Tuple[List[EbayReturn], int]

    @staticmethod
    def list_by_state(db: Session, state: str, limit: int = 100) -> List[EbayReturn]

    @staticmethod
    def list_needs_action(db: Session, limit: int = 100) -> List[EbayReturn]

    @staticmethod
    def list_past_deadline(db: Session, limit: int = 100) -> List[EbayReturn]

    # Aggregation
    @staticmethod
    def count_by_state(db: Session, state: str) -> int

    @staticmethod
    def exists(db: Session, ebay_return_id: str) -> bool
```

**Acceptance Criteria**:
- [ ] All CRUD methods implemented
- [ ] Query methods with proper filtering
- [ ] Special queries: needs_action, past_deadline
- [ ] Uses existing repository patterns

---

### Task 2: Create EbayReturnSyncService

**Goal**: Create sync service to fetch returns from eBay and store in DB.

**Files to create**:
- `backend/services/ebay/ebay_return_sync_service.py`

**Implementation**:

```python
class EbayReturnSyncService:
    """Service to sync eBay returns to local database."""

    def __init__(self, db: Session, user_id: int):
        self.db = db
        self.user_id = user_id
        self.return_client = EbayReturnClient(db, user_id)

    def sync_returns(
        self,
        return_state: Optional[str] = None,
        days_back: int = 30,
    ) -> dict:
        """
        Sync returns from eBay to local DB.

        Returns:
            Stats dict: {created, updated, skipped, errors, total_fetched}
        """

    def _process_single_return(self, api_return: dict) -> dict:
        """Process single return from API."""

    def _map_api_return_to_model(self, api_return: dict) -> dict:
        """Map eBay API return data to EbayReturn model fields."""

    @staticmethod
    def _parse_date(date_str: Optional[str]) -> Optional[datetime]

    @staticmethod
    def _parse_float(value_str: Optional[str]) -> Optional[float]
```

**Key mapping** (API → Model):
- `returnId` → `return_id`
- `orderId` → `order_id`
- `state` → `state` (OPEN, CLOSED)
- `status` → `status` (RETURN_REQUESTED, etc.)
- `returnType` → `return_type`
- `returnReason` → `reason`
- `returnReasonDescription` → `reason_detail`
- `refundAmount.value` → `refund_amount`
- `refundAmount.currency` → `refund_currency`
- `buyer.username` → `buyer_username`
- `creationDate` → `creation_date`
- `sellerResponseDue.deadline` → `deadline_date`
- Full response → `raw_data`

**Acceptance Criteria**:
- [ ] Sync method with pagination handling
- [ ] Create or update logic
- [ ] Proper date/float parsing
- [ ] Statistics return (like EbayOrderSyncService)

---

### Task 3: Create EbayReturnService

**Goal**: Create service for return business operations.

**Files to create**:
- `backend/services/ebay/ebay_return_service.py`

**Implementation**:

```python
class EbayReturnService:
    """Service for eBay return business operations."""

    def __init__(self, db: Session, user_id: int):
        self.db = db
        self.user_id = user_id
        self.return_client = EbayReturnClient(db, user_id)

    # Read operations
    def get_return(self, return_id: int) -> Optional[EbayReturn]:
        """Get return by internal ID."""

    def get_return_by_ebay_id(self, ebay_return_id: str) -> Optional[EbayReturn]:
        """Get return by eBay return ID."""

    def list_returns(
        self,
        skip: int = 0,
        limit: int = 50,
        state: Optional[str] = None,
        status: Optional[str] = None,
    ) -> Tuple[List[EbayReturn], int]:
        """List returns with pagination and filters."""

    def get_returns_needing_action(self) -> List[EbayReturn]:
        """Get returns requiring seller action."""

    def get_returns_past_deadline(self) -> List[EbayReturn]:
        """Get returns past deadline (urgent)."""

    # Action operations (call eBay API + update local)
    def accept_return(
        self,
        return_id: int,
        comments: Optional[str] = None,
        rma_number: Optional[str] = None,
    ) -> dict:
        """Accept a return request."""

    def decline_return(
        self,
        return_id: int,
        comments: str,
    ) -> dict:
        """Decline a return request."""

    def issue_refund(
        self,
        return_id: int,
        refund_amount: Optional[float] = None,
        currency: Optional[str] = None,
        comments: Optional[str] = None,
    ) -> dict:
        """Issue refund for a return."""

    def mark_as_received(
        self,
        return_id: int,
        comments: Optional[str] = None,
    ) -> dict:
        """Mark return item as received."""

    def send_message(
        self,
        return_id: int,
        message: str,
    ) -> dict:
        """Send message to buyer about return."""

    # Statistics
    def get_return_statistics(self) -> dict:
        """Get return stats (open, closed, needs_action, past_deadline)."""
```

**Acceptance Criteria**:
- [ ] All read operations via repository
- [ ] Action operations: API call + local update
- [ ] Statistics aggregation
- [ ] Proper error handling

---

### Task 4: Write Unit Tests

**Goal**: Unit tests for repository and services.

**Files to create**:
- `backend/tests/unit/services/ebay/test_ebay_return_sync_service.py`
- `backend/tests/unit/services/ebay/test_ebay_return_service.py`

**Test coverage**:
- Repository: CRUD, queries, aggregations
- SyncService: sync_returns, mapping, create/update logic
- ReturnService: read operations, action operations, statistics

**Acceptance Criteria**:
- [ ] Repository tests
- [ ] SyncService tests (mocked client)
- [ ] ReturnService tests (mocked client + repository)

---

## Execution Order

1. **Task 1**: Create `EbayReturnRepository` (data access)
2. **Task 2**: Create `EbayReturnSyncService` (eBay → DB)
3. **Task 3**: Create `EbayReturnService` (business logic)
4. **Task 4**: Write unit tests

## Dependencies

- `EbayReturnClient` from Phase 2
- `EbayReturn` model from Phase 2
- `EbayOrderRepository` pattern for reference

## Testing Strategy

- Unit tests with mocked dependencies
- Test files in `backend/tests/unit/services/ebay/`

---

*Plan created: 2026-01-13*
