# Plan 01-01: Post-Order API Base Client

## Context

Phase 1 (Foundation) establishes the base infrastructure for eBay post-sale management (returns, cancellations, inquiries).

**Key Discovery**: The Post-Order API is an eBay "traditional API" that uses OAuth tokens but without specific scopes like RESTful APIs. The same user access token generated with existing scopes will work for Post-Order API calls.

**API Base URL**: `https://api.ebay.com/post-order/v2/`

## Tasks

### Task 1: Create EbayPostOrderBaseClient

**Goal**: Create a dedicated base client for Post-Order API following existing patterns.

**Files to create**:
- `backend/services/ebay/ebay_post_order_client.py`

**Implementation**:

```python
"""
eBay Post-Order API Base Client.

Client for Post-Order API (cancellations, returns, inquiries).
Inherits from EbayBaseClient for OAuth handling.

Post-Order API is a "traditional API" that uses the same OAuth tokens
but different base URL: https://api.ebay.com/post-order/v2/

Documentation:
https://developer.ebay.com/devzone/post-order/index.html
"""

from typing import Any, Dict, Optional
from sqlalchemy.orm import Session
from services.ebay.ebay_base_client import EbayBaseClient


class EbayPostOrderClient(EbayBaseClient):
    """
    Base client for eBay Post-Order API v2.

    Provides api_call_post_order() method for Post-Order endpoints.
    Subclasses will implement specific domain methods (returns, cancellations, inquiries).
    """

    # Post-Order API Base URLs (different from standard API)
    POST_ORDER_BASE_SANDBOX = "https://api.sandbox.ebay.com/post-order/v2"
    POST_ORDER_BASE_PRODUCTION = "https://api.ebay.com/post-order/v2"

    def __init__(
        self,
        db: Session,
        user_id: int,
        marketplace_id: Optional[str] = None,
        sandbox: bool = False,
    ):
        super().__init__(db, user_id, marketplace_id, sandbox)
        self.post_order_base = (
            self.POST_ORDER_BASE_SANDBOX if self.sandbox
            else self.POST_ORDER_BASE_PRODUCTION
        )

    def api_call_post_order(
        self,
        method: str,
        path: str,
        params: Optional[Dict[str, Any]] = None,
        json_data: Optional[Dict[str, Any]] = None,
    ) -> Any:
        """
        API call specific to Post-Order API.

        Uses Post-Order base URL instead of standard API base URL.
        The token is the same (inherited from EbayBaseClient).

        Args:
            method: HTTP method (GET, POST, PUT)
            path: Endpoint path (e.g., "/cancellation/search")
            params: Query parameters
            json_data: Request body JSON

        Returns:
            Response JSON or None
        """
        # Build full URL with Post-Order base
        url = f"{self.post_order_base}{path}"

        # Get OAuth token (same as RESTful APIs)
        token = self.get_access_token()

        # Headers for Post-Order API
        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json",
            "Accept": "application/json",
            "X-EBAY-C-MARKETPLACE-ID": self.marketplace_id or "EBAY_FR",
        }

        # Rate limiting
        if not hasattr(self, '_rate_limiter'):
            from shared.http_client import RateLimiter
            self._rate_limiter = RateLimiter(min_delay=0.3, max_delay=0.8)
        self._rate_limiter.wait()

        # Log and execute
        from shared.logging_setup import get_logger
        logger = get_logger(__name__)
        logger.debug(f"eBay Post-Order API {method} {path}")

        import requests
        from shared.exceptions import EbayAPIError, EbayOAuthError, MarketplaceRateLimitError

        try:
            resp = requests.request(
                method.upper(),
                url,
                headers=headers,
                params=params,
                json=json_data,
                timeout=30,
            )

            if not resp.ok:
                error_data = None
                try:
                    error_data = resp.json()
                except:
                    error_data = {"raw_text": resp.text[:500] if resp.text else None}

                if resp.status_code == 429:
                    retry_after = resp.headers.get("Retry-After")
                    raise MarketplaceRateLimitError(
                        platform="ebay",
                        retry_after=int(retry_after) if retry_after else None,
                        operation=method.lower(),
                    )

                if resp.status_code in (401, 403):
                    raise EbayOAuthError(
                        message=f"Post-Order API auth failed ({resp.status_code})",
                        status_code=resp.status_code,
                        response_body=error_data,
                    )

                raise EbayAPIError(
                    message=f"Post-Order API error {resp.status_code} on {method} {path}",
                    status_code=resp.status_code,
                    response_body=error_data,
                )

            if resp.status_code in (204,) or not resp.text:
                return None

            return resp.json()

        except requests.exceptions.Timeout as e:
            from shared.exceptions import EbayError
            raise EbayError(
                message=f"Timeout on Post-Order {method} {path}: {e}",
                operation=method.lower(),
            ) from e
        except requests.exceptions.RequestException as e:
            from shared.exceptions import EbayError
            raise EbayError(
                message=f"Network error on Post-Order {method} {path}: {e}",
                operation=method.lower(),
            ) from e
```

**Acceptance Criteria**:
- [ ] `EbayPostOrderClient` extends `EbayBaseClient`
- [ ] `api_call_post_order()` uses correct Post-Order base URL
- [ ] Same OAuth token mechanism as existing clients
- [ ] Proper error handling with existing exception types
- [ ] Rate limiting applied

---

### Task 2: Create Shared Enums and Types

**Goal**: Create shared enumerations for post-sale statuses that will be used across returns, cancellations, and inquiries.

**Files to create**:
- `backend/services/ebay/post_order_types.py`

**Implementation**:

```python
"""
eBay Post-Order API Shared Types and Enums.

Enumerations for returns, cancellations, and inquiries statuses.
Used by models, services, and API schemas.
"""

from enum import Enum


# ========== CANCELLATION TYPES ==========

class CancellationStatus(str, Enum):
    """Cancellation request status."""
    CANCEL_REQUESTED = "CANCEL_REQUESTED"
    CANCEL_PENDING = "CANCEL_PENDING"
    CANCEL_CLOSED_NO_REFUND = "CANCEL_CLOSED_NO_REFUND"
    CANCEL_CLOSED_WITH_REFUND = "CANCEL_CLOSED_WITH_REFUND"
    CANCEL_CLOSED_UNKNOWN_REFUND = "CANCEL_CLOSED_UNKNOWN_REFUND"
    CANCEL_CLOSED_FOR_COMMITMENT = "CANCEL_CLOSED_FOR_COMMITMENT"


class CancellationReason(str, Enum):
    """Reason for cancellation."""
    BUYER_ASKED_CANCEL = "BUYER_ASKED_CANCEL"
    BUYER_NO_SHOW = "BUYER_NO_SHOW"
    BUYER_CANCEL = "BUYER_CANCEL"
    ORDER_UNPAID = "ORDER_UNPAID"
    OUT_OF_STOCK = "OUT_OF_STOCK"
    SELLER_CANCEL = "SELLER_CANCEL"
    ADDRESS_ISSUES = "ADDRESS_ISSUES"
    PRICE_ERROR = "PRICE_ERROR"
    OTHER = "OTHER"


# ========== RETURN TYPES ==========

class ReturnStatus(str, Enum):
    """Return request status."""
    RETURN_REQUESTED = "RETURN_REQUESTED"
    RETURN_WAITING_FOR_RMA = "RETURN_WAITING_FOR_RMA"
    RETURN_WAITING_FOR_SHIPPING_LABEL = "RETURN_WAITING_FOR_SHIPPING_LABEL"
    RETURN_SHIPPING_LABEL_CREATED = "RETURN_SHIPPING_LABEL_CREATED"
    RETURN_ITEM_SHIPPED = "RETURN_ITEM_SHIPPED"
    RETURN_ITEM_DELIVERED = "RETURN_ITEM_DELIVERED"
    RETURN_CLOSED = "RETURN_CLOSED"
    PARTIAL_REFUND_REQUESTED = "PARTIAL_REFUND_REQUESTED"
    PARTIAL_REFUND_DECLINED = "PARTIAL_REFUND_DECLINED"
    PARTIAL_REFUND_FAILED = "PARTIAL_REFUND_FAILED"
    REFUND_INITIATED = "REFUND_INITIATED"


class ReturnReason(str, Enum):
    """Reason for return."""
    ARRIVED_DAMAGED = "ARRIVED_DAMAGED"
    ARRIVED_LATE = "ARRIVED_LATE"
    BUYER_CANCEL = "BUYER_CANCEL"
    BUYER_REMORSE = "BUYER_REMORSE"
    DEFECTIVE_ITEM = "DEFECTIVE_ITEM"
    DIFFERENT_FROM_LISTING = "DIFFERENT_FROM_LISTING"
    MISSING_PARTS = "MISSING_PARTS"
    NOT_AS_DESCRIBED = "NOT_AS_DESCRIBED"
    WRONG_ITEM = "WRONG_ITEM"
    OTHER = "OTHER"


class ReturnType(str, Enum):
    """Type of return."""
    RETURN = "RETURN"
    REPLACEMENT = "REPLACEMENT"
    REFUND_ONLY = "REFUND_ONLY"


# ========== INQUIRY TYPES ==========

class InquiryStatus(str, Enum):
    """INR Inquiry status."""
    OPEN = "OPEN"
    CLOSED = "CLOSED"
    ON_HOLD = "ON_HOLD"
    ESCALATED = "ESCALATED"


class InquiryType(str, Enum):
    """Type of inquiry."""
    INR = "INR"  # Item Not Received


# ========== PAYMENT DISPUTE TYPES ==========

class PaymentDisputeStatus(str, Enum):
    """Payment dispute status."""
    OPEN = "OPEN"
    WAITING_FOR_SELLER = "WAITING_FOR_SELLER"
    ACTION_NEEDED = "ACTION_NEEDED"
    CLOSED = "CLOSED"
    PROCESSING = "PROCESSING"


class PaymentDisputeReason(str, Enum):
    """Reason for payment dispute."""
    INR = "INR"  # Item Not Received
    SNAD = "SNAD"  # Significantly Not As Described
    UNAUTHORIZED = "UNAUTHORIZED"  # Unauthorized purchase


# ========== REFUND TYPES ==========

class RefundStatus(str, Enum):
    """Refund status."""
    PENDING = "PENDING"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"


class RefundType(str, Enum):
    """Type of refund."""
    FULL = "FULL"
    PARTIAL = "PARTIAL"
```

**Acceptance Criteria**:
- [ ] All enums are str-based for JSON serialization
- [ ] Covers all domains: cancellations, returns, inquiries, disputes, refunds
- [ ] Values match eBay API documentation

---

### Task 3: Add Post-Order Scopes to OAuth Config (Verification)

**Goal**: Verify that the existing OAuth scopes are sufficient for Post-Order API. Add any missing scopes if needed.

**Files to update**:
- `backend/services/ebay/ebay_oauth_config.py` (if needed)
- `backend/services/ebay/ebay_base_client.py` (add scope constants)

**Research finding**: Post-Order API is a "traditional API" that uses the same OAuth user token. The `api_scope` scope provides access to traditional APIs. Our current configuration already includes this scope.

**Verification steps**:
1. Confirm `https://api.ebay.com/oauth/api_scope` is in EBAY_SCOPES ✓
2. Confirm `sell.fulfillment` scope is present for refunds ✓

**No code changes needed** - existing scopes are sufficient.

**Acceptance Criteria**:
- [ ] Verify `api_scope` is included in `EBAY_SCOPES` (already present)
- [ ] Document that Post-Order API uses same token as RESTful APIs
- [ ] Add comment to `ebay_oauth_config.py` explaining Post-Order access

---

## Execution Order

1. **Task 1**: Create `EbayPostOrderClient` (main deliverable)
2. **Task 2**: Create shared enums in `post_order_types.py`
3. **Task 3**: Verify OAuth scopes (documentation only)

## Dependencies

- Existing `EbayBaseClient` in `services/ebay/ebay_base_client.py`
- Existing exception types in `shared/exceptions.py`
- Existing `RateLimiter` in `shared/http_client.py`

## Testing Strategy

- Unit tests for `EbayPostOrderClient.api_call_post_order()`
- Mock responses for success/error scenarios
- Test file: `backend/tests/unit/services/ebay/test_ebay_post_order_client.py`

## Estimated Effort

- Task 1: ~30 minutes
- Task 2: ~15 minutes
- Task 3: ~5 minutes (verification only)
- **Total**: ~50 minutes

---

*Plan created: 2026-01-13*
