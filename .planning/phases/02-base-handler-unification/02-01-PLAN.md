# Phase 2 Plan: Base Handler Unification

## Objective

Clean up dual BaseHandler architecture by removing dead `BaseMarketplaceHandler` code and standardizing all handlers on `BaseJobHandler`. Integrate TaskOrchestrator from Phase 1 into BaseJobHandler for task-based execution.

## Context

**Problem**: Currently have two incompatible base handler classes:

1. **BaseJobHandler** (`backend/services/vinted/jobs/base_job_handler.py`)
   - ✅ Used by ALL active job handlers (15 handlers)
   - ✅ Modern async architecture with `execute(job: MarketplaceJob)`
   - ✅ WebSocket support for Vinted plugin
   - ✅ Direct HTTP support for eBay/Etsy
   - ⚠️ Missing TaskOrchestrator integration

2. **BaseMarketplaceHandler** (`backend/services/marketplace/handlers/base_handler.py`)
   - ❌ Dead code - only used by 4 obsolete handlers in `marketplace/handlers/`
   - ❌ Legacy `create_task()` method (pre-TaskOrchestrator)
   - ❌ Complex task execution methods no longer used
   - ❌ Bloated codebase (343 lines vs 186 for BaseJobHandler)

**Audit Results**:

| Handler Type | Count | Base Class | Status |
|--------------|-------|------------|--------|
| Active job handlers | 15 | `BaseJobHandler` | ✅ Modern |
| Obsolete marketplace handlers | 4 | `BaseMarketplaceHandler` | ❌ Dead code |

**Active handlers using BaseJobHandler**:
- Vinted: 7 handlers (publish, update, delete, link_product, sync, orders, message)
- eBay: 5 handlers (publish, update, delete, sync, orders_sync)
- Etsy: 5 handlers (publish, update, delete, sync, orders_sync)

**Dead handlers using BaseMarketplaceHandler**:
- `marketplace/handlers/vinted/publish_handler.py` (replaced by `vinted/jobs/publish_job_handler.py`)
- `marketplace/handlers/ebay/publish_handler.py` (replaced by `ebay/jobs/ebay_publish_job_handler.py`)
- `marketplace/handlers/etsy/publish_handler.py` (replaced by `etsy/jobs/etsy_publish_job_handler.py`)
- `marketplace/handlers/vinted/link_product_handler.py` (replaced by `vinted/jobs/link_product_job_handler.py`)
- `marketplace/handlers/base_publish_handler.py` (parent of above, also dead)

## Execution Context

@backend/services/vinted/jobs/base_job_handler.py
@backend/services/marketplace/handlers/base_handler.py
@backend/services/marketplace/handlers/base_publish_handler.py
@backend/services/marketplace/task_orchestrator.py

## Tasks

### Task 1: Document Current Handler Architecture

**Goal**: Create clear documentation of handler architecture before changes.

**Validation**:
- Create `HANDLER_ARCHITECTURE.md` in `.planning/phases/02-base-handler-unification/`
- Document all 15 active handlers with their base class
- Document 4 dead handlers with their base class
- Document BaseJobHandler interface (methods, signature)
- Document BaseMarketplaceHandler interface (methods, signature)
- List differences between the two base classes

**Output**: Clear reference document for architecture understanding.

### Task 2: Delete Dead BaseMarketplaceHandler Code

**Goal**: Remove all dead code related to BaseMarketplaceHandler.

**Steps**:
1. Delete `backend/services/marketplace/handlers/base_handler.py` (343 lines)
2. Delete `backend/services/marketplace/handlers/base_publish_handler.py` (parent class)
3. Delete 4 obsolete handler files:
   - `marketplace/handlers/vinted/publish_handler.py`
   - `marketplace/handlers/ebay/publish_handler.py`
   - `marketplace/handlers/etsy/publish_handler.py`
   - `marketplace/handlers/vinted/link_product_handler.py`
4. Delete empty directories if any (`marketplace/handlers/vinted/`, `marketplace/handlers/ebay/`, `marketplace/handlers/etsy/`)
5. Update `backend/services/marketplace/handlers/__init__.py` (remove BaseMarketplaceHandler export)

**Validation**:
- Run `grep -r "BaseMarketplaceHandler" backend/` → no results
- Run `grep -r "BasePublishHandler" backend/` → no results
- Run `pytest backend/tests/` → all tests pass (or fail for unrelated reasons)
- No imports of deleted files remain

**Output**: Codebase with single base handler architecture (BaseJobHandler only).

### Task 3: Add create_tasks() Abstract Method to BaseJobHandler

**Goal**: Standardize task creation interface in BaseJobHandler.

**Implementation**:
```python
# In backend/services/vinted/jobs/base_job_handler.py

from abc import ABC, abstractmethod
from typing import List

class BaseJobHandler(ABC):
    """Base class for all marketplace job handlers."""

    # ... existing code ...

    @abstractmethod
    def create_tasks(self, job: MarketplaceJob) -> List[str]:
        """
        Define the list of task names for this job type.

        Each handler must implement this to define its execution steps.
        TaskOrchestrator will create MarketplaceTask objects from these names.

        Args:
            job: The MarketplaceJob to create tasks for

        Returns:
            List of task names in execution order (e.g., ["Validate product", "Upload image 1/3", "Publish listing"])

        Example:
            def create_tasks(self, job: MarketplaceJob) -> List[str]:
                # For a publish job with 3 images
                return [
                    "Validate product data",
                    "Upload image 1/3",
                    "Upload image 2/3",
                    "Upload image 3/3",
                    "Create Vinted listing"
                ]
        """
        pass
```

**Validation**:
- Abstract method added to BaseJobHandler
- Docstring includes clear example
- Type hints are correct (`List[str]`)
- No changes to existing handlers yet (they don't implement yet)

**Output**: BaseJobHandler with new abstract method interface.

### Task 4: Integrate TaskOrchestrator into BaseJobHandler

**Goal**: Add TaskOrchestrator integration to BaseJobHandler for task-based execution.

**Implementation**:
```python
# In backend/services/vinted/jobs/base_job_handler.py

from services.marketplace.task_orchestrator import TaskOrchestrator

class BaseJobHandler(ABC):
    """Base class for all marketplace job handlers."""

    def __init__(
        self,
        db: Session,
        shop_id: int | None = None,
        job_id: int | None = None
    ):
        self.db = db
        self.shop_id = shop_id
        self.job_id = job_id
        self.user_id: Optional[int] = None

        # NEW: TaskOrchestrator instance for task management
        self.orchestrator = TaskOrchestrator(db)

    @abstractmethod
    async def execute(self, job: MarketplaceJob) -> dict[str, Any]:
        """Execute the job (to be implemented by subclasses)."""
        pass

    @abstractmethod
    def create_tasks(self, job: MarketplaceJob) -> List[str]:
        """Define task names for this job type (to be implemented by subclasses)."""
        pass

    # NEW: Helper method for task-based execution
    async def execute_with_tasks(
        self,
        job: MarketplaceJob,
        handlers: dict[str, Callable[[MarketplaceTask], dict]]
    ) -> dict[str, Any]:
        """
        Execute job using TaskOrchestrator with retry intelligence.

        This is a helper method that handlers CAN use (but are not required to).
        It provides automatic task creation, execution tracking, and retry intelligence.

        Workflow:
        1. Create tasks using handler's create_tasks() method
        2. Execute tasks in order with TaskOrchestrator
        3. Skip completed tasks on retry
        4. Stop on first failure

        Args:
            job: MarketplaceJob to execute
            handlers: Dict mapping task name -> handler function
                     Each handler receives a MarketplaceTask and returns result dict

        Returns:
            dict: {
                "success": bool,
                "tasks_completed": int,
                "tasks_total": int,
                "error": str | None
            }

        Example:
            async def execute(self, job: MarketplaceJob) -> dict[str, Any]:
                # Define handlers for each task
                handlers = {
                    "Validate product data": self._validate_product,
                    "Upload image 1/3": lambda task: self._upload_image(task, 0),
                    "Upload image 2/3": lambda task: self._upload_image(task, 1),
                    "Upload image 3/3": lambda task: self._upload_image(task, 2),
                    "Create Vinted listing": self._create_listing,
                }

                # Execute with automatic retry intelligence
                return await self.execute_with_tasks(job, handlers)
        """
        # 1. Create tasks if not already created
        existing_tasks = self.db.query(MarketplaceTask).filter(
            MarketplaceTask.job_id == job.id
        ).all()

        if not existing_tasks:
            task_names = self.create_tasks(job)
            tasks = self.orchestrator.create_tasks(job, task_names)
            self.log_debug(f"Created {len(tasks)} tasks for job #{job.id}")
        else:
            tasks = existing_tasks
            self.log_debug(f"Found {len(tasks)} existing tasks for job #{job.id}")

        # 2. Execute tasks with retry intelligence
        success = self.orchestrator.execute_job_with_tasks(job, tasks, handlers)

        # 3. Count completed tasks
        completed = sum(1 for t in tasks if t.status == TaskStatus.SUCCESS)

        # 4. Return result
        if success:
            return {
                "success": True,
                "tasks_completed": completed,
                "tasks_total": len(tasks)
            }
        else:
            # Find first failed task for error message
            failed_task = next((t for t in tasks if t.status == TaskStatus.FAILED), None)
            return {
                "success": False,
                "tasks_completed": completed,
                "tasks_total": len(tasks),
                "error": failed_task.error_message if failed_task else "Unknown error"
            }
```

**Validation**:
- `TaskOrchestrator` imported and instantiated in `__init__`
- `execute_with_tasks()` method added with full docstring
- Method includes example usage in docstring
- Method handles both new jobs (create tasks) and retries (use existing tasks)
- Method returns standardized result dict
- No changes to existing handlers yet (they don't use this yet)

**Output**: BaseJobHandler with TaskOrchestrator integration ready for handlers to adopt.

### Task 5: Write Tests for BaseJobHandler TaskOrchestrator Integration

**Goal**: Test new TaskOrchestrator integration in BaseJobHandler.

**Approach**: Pragmatic test-after (not TDD) since this is integration code.

**Test File**: `backend/tests/unit/services/test_base_job_handler_orchestration.py`

**Test Cases**:
```python
class TestBaseJobHandlerOrchestration:
    """Tests for BaseJobHandler TaskOrchestrator integration."""

    def test_orchestrator_initialized_in_constructor(self):
        """Should create TaskOrchestrator instance in __init__."""

    def test_execute_with_tasks_creates_tasks_on_first_run(self):
        """Should create tasks using handler's create_tasks() method."""

    def test_execute_with_tasks_reuses_existing_tasks_on_retry(self):
        """Should not recreate tasks if they already exist."""

    def test_execute_with_tasks_returns_success_when_all_tasks_succeed(self):
        """Should return success=True when all tasks complete."""

    def test_execute_with_tasks_returns_failure_with_error_message(self):
        """Should return success=False with error when task fails."""

    def test_execute_with_tasks_counts_completed_tasks_correctly(self):
        """Should count tasks_completed and tasks_total accurately."""
```

**Implementation Notes**:
- Use a concrete test handler that implements `create_tasks()` and `execute()`
- Mock TaskOrchestrator methods if needed
- Test both first execution and retry scenarios

**Validation**:
- All 6 tests pass
- Coverage of new `execute_with_tasks()` method > 90%
- Tests demonstrate correct integration with TaskOrchestrator

**Output**: Test suite validating BaseJobHandler TaskOrchestrator integration.

### Task 6: Update HANDLER_ARCHITECTURE.md with Final State

**Goal**: Document the unified architecture after changes.

**Updates**:
- Remove BaseMarketplaceHandler section (deleted)
- Add TaskOrchestrator integration section
- Add `create_tasks()` method documentation
- Add `execute_with_tasks()` method documentation
- Add migration guide for existing handlers (optional, for Phase 3+)

**Validation**:
- Documentation reflects current state
- All code examples are accurate
- Migration guide is clear and actionable

**Output**: Complete documentation of unified handler architecture.

## Verification

### Success Criteria

✅ **Single Base Handler Architecture**
- Only `BaseJobHandler` exists in codebase
- No references to `BaseMarketplaceHandler` or `BasePublishHandler`
- All 15 active handlers inherit from `BaseJobHandler`

✅ **TaskOrchestrator Integration**
- `TaskOrchestrator` instantiated in `BaseJobHandler.__init__`
- `create_tasks()` abstract method exists
- `execute_with_tasks()` helper method exists
- Helper method includes clear docstring with example

✅ **Dead Code Removed**
- ~343 lines removed (base_handler.py)
- ~100 lines removed (base_publish_handler.py)
- ~400 lines removed (4 obsolete handlers)
- **Total: ~843 lines deleted**

✅ **Tests Pass**
- All existing tests still pass
- 6 new tests for TaskOrchestrator integration pass
- Coverage of new methods > 90%

✅ **Documentation Complete**
- `HANDLER_ARCHITECTURE.md` created and updated
- Clear before/after comparison
- Migration guide for future phases (optional)

### Verification Commands

```bash
# 1. Verify BaseMarketplaceHandler is gone
grep -r "BaseMarketplaceHandler" backend/
# Expected: no results

# 2. Verify all handlers use BaseJobHandler
grep -r "class.*Handler.*\(" backend/services --include="*.py" | grep -v BaseJobHandler
# Expected: no results (or only BaseJobHandler itself)

# 3. Run tests
cd backend
pytest tests/unit/services/test_base_job_handler_orchestration.py -v
# Expected: 6/6 pass

# 4. Run full test suite
pytest tests/ -v
# Expected: all pass (or fail for unrelated reasons)

# 5. Check coverage of new code
pytest tests/unit/services/test_base_job_handler_orchestration.py --cov=services.vinted.jobs.base_job_handler --cov-report=term-missing
# Expected: >90% coverage of execute_with_tasks()
```

## Output

**Files Modified**:
- `backend/services/vinted/jobs/base_job_handler.py` (+50 lines: abstract method + helper method)

**Files Deleted**:
- `backend/services/marketplace/handlers/base_handler.py` (-343 lines)
- `backend/services/marketplace/handlers/base_publish_handler.py` (-~100 lines)
- `backend/services/marketplace/handlers/vinted/publish_handler.py` (-~100 lines)
- `backend/services/marketplace/handlers/ebay/publish_handler.py` (-~100 lines)
- `backend/services/marketplace/handlers/etsy/publish_handler.py` (-~100 lines)
- `backend/services/marketplace/handlers/vinted/link_product_handler.py` (-~100 lines)

**Files Created**:
- `.planning/phases/02-base-handler-unification/HANDLER_ARCHITECTURE.md` (documentation)
- `backend/tests/unit/services/test_base_job_handler_orchestration.py` (tests)

**Net Impact**: ~800 lines deleted, ~100 lines added → **~700 lines removed**

**Commits**: 4-5 commits (document, delete, add method, integrate, test)

## Notes

**Why This Phase is Safe**:
- Only deleting dead code (no active handlers affected)
- Adding optional helper method (handlers not required to use it yet)
- Abstract method `create_tasks()` won't break existing code (they already work without it)
- Handlers will adopt TaskOrchestrator incrementally in future phases

**Migration Strategy for Future Phases**:
- Phase 3+: Update individual handlers to implement `create_tasks()` and use `execute_with_tasks()`
- Handlers can be migrated one at a time
- No breaking changes to existing functionality

**Estimated Duration**: ~4 hours
- Task 1 (Document): 30 min
- Task 2 (Delete dead code): 30 min
- Task 3 (Add abstract method): 15 min
- Task 4 (Integrate TaskOrchestrator): 60 min
- Task 5 (Write tests): 90 min
- Task 6 (Update docs): 15 min

---

*Created: 2026-01-15*
*Phase: 02 Base Handler Unification*
*Prerequisites: Phase 1 (Task Orchestration Foundation) complete*
