---
phase: 07-testing-polish
plan: 01
type: execute
---

<objective>
Configure frontend test infrastructure and implement comprehensive tests for pricing composable.

Purpose: Unblock frontend testing by configuring @nuxt/test-utils, then implement the 9 test scenarios documented in usePricingCalculation.spec.ts TODO.

Output: Fully tested pricing composable with Vitest + @nuxt/test-utils configuration, 9+ passing tests covering all functionality.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-phase.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-frontend-ui/06-01-SUMMARY.md
@.planning/phases/06-frontend-ui/06-02-SUMMARY.md

**Phase dependencies:**
- Phase 6 Plan 1: usePricingCalculation composable created with TODO tests
- Test blocker identified: Vitest doesn't support Nuxt auto-imports (useApi)
- Test structure exists: frontend/tests/unit/usePricingCalculation.spec.ts (33 lines with TODO)

**Tech stack available:**
- Frontend: Nuxt.js 3, Vue 3 Composition API, TypeScript, Vitest
- Composable: usePricingCalculation with calculatePrice(), reset()
- Backend API: POST /api/pricing/calculate (fully tested in Phase 5)

**Key files:**
- frontend/composables/usePricingCalculation.ts (95 lines)
- frontend/tests/unit/usePricingCalculation.spec.ts (33 lines, TODO structure)

**Test scenarios documented in TODO:**
1. Initial state validation (isLoading, error, priceResult)
2. Loading state during calculation
3. Successful price calculation
4. 400 validation error handling
5. 500 generation error handling
6. 504 timeout error handling
7. Generic error handling
8. Reset functionality
9. Multiple sequential calculations
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure @nuxt/test-utils for Vitest</name>
  <files>frontend/vitest.config.ts, frontend/package.json</files>
  <action>
Install @nuxt/test-utils for Vitest compatibility:

**1. Install dependencies:**
```bash
cd frontend
npm install -D @nuxt/test-utils vitest @vue/test-utils happy-dom
```

**2. Create/update vitest.config.ts:**
```typescript
import { defineConfig } from 'vitest/config'
import vue from '@vitejs/plugin-vue'
import { fileURLToPath } from 'node:url'

export default defineConfig({
  plugins: [vue()],
  test: {
    environment: 'happy-dom',
    globals: true,
    setupFiles: ['./tests/setup.ts'],
  },
  resolve: {
    alias: {
      '~': fileURLToPath(new URL('./', import.meta.url)),
      '@': fileURLToPath(new URL('./', import.meta.url)),
    },
  },
})
```

**3. Create tests/setup.ts:**
```typescript
import { vi } from 'vitest'

// Mock Nuxt auto-imports
global.useApi = vi.fn()
global.ref = vi.fn()
global.readonly = vi.fn()
global.computed = vi.fn()

// Mock any other Nuxt composables as needed
```

**4. Update package.json scripts:**
Add `"test": "vitest"` and `"test:ui": "vitest --ui"` to scripts section.

**Why this approach:**
- @nuxt/test-utils provides Nuxt-aware testing utilities
- happy-dom is lightweight DOM implementation for Vitest
- Setup file mocks Nuxt auto-imports to unblock tests
- Alias configuration matches Nuxt's path resolution
  </action>
  <verify>
Run `cd frontend && npm test -- --run` - should execute without "cannot find module" errors (may have 0 tests or skipped tests, that's expected at this stage)
  </verify>
  <done>
- vitest.config.ts exists with correct configuration
- tests/setup.ts created with auto-import mocks
- package.json has test scripts
- `npm test -- --run` executes without module resolution errors
- No build or TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement usePricingCalculation tests</name>
  <files>frontend/tests/unit/usePricingCalculation.spec.ts</files>
  <action>
Replace the TODO structure with comprehensive test implementation covering all 9 scenarios:

**Test structure:**
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { ref, readonly } from 'vue'

// Import the composable
// Note: May need to adjust import based on how mocking works
describe('usePricingCalculation', () => {
  let mockApiPost: ReturnType<typeof vi.fn>

  beforeEach(() => {
    vi.clearAllMocks()
    mockApiPost = vi.fn()

    // Mock useApi to return our mock post function
    vi.mocked(global.useApi).mockReturnValue({
      post: mockApiPost
    })
  })

  describe('Initial State', () => {
    it('should initialize with default state', () => {
      // Test: isLoading = false, error = null, priceResult = null
    })
  })

  describe('Loading State', () => {
    it('should set loading to true during calculation', async () => {
      // Test: isLoading becomes true, then false after completion
    })
  })

  describe('Successful Calculation', () => {
    it('should handle successful price calculation', async () => {
      const mockResult = {
        quick_price: '75.00',
        standard_price: '100.00',
        premium_price: '130.00',
        base_price: '100.00',
        model_coefficient: 1.0,
        adjustments: {
          condition: 0.0,
          origin: 0.0,
          decade: 0.0,
          trend: 0.0,
          feature: 0.0,
          total: 0.0
        },
        brand: 'Test Brand',
        group: 'jacket_leather'
      }

      mockApiPost.mockResolvedValue({ data: mockResult })

      // Call calculatePrice, verify priceResult matches mockResult
    })
  })

  describe('Error Handling', () => {
    it('should handle 400 validation error', async () => {
      mockApiPost.mockRejectedValue({
        response: { status: 400, data: { detail: 'Invalid input' } }
      })

      // Verify error.value contains 'Invalid product data'
    })

    it('should handle 500 generation error', async () => {
      mockApiPost.mockRejectedValue({
        response: { status: 500 }
      })

      // Verify error.value contains 'Failed to generate pricing data'
    })

    it('should handle 504 timeout error', async () => {
      mockApiPost.mockRejectedValue({
        response: { status: 504 }
      })

      // Verify error.value contains 'timed out'
    })

    it('should handle generic errors', async () => {
      mockApiPost.mockRejectedValue({
        response: { status: 418, data: { detail: 'Teapot error' } }
      })

      // Verify error.value contains the detail message
    })
  })

  describe('Reset Functionality', () => {
    it('should reset state', () => {
      // Set state, call reset(), verify null values
    })
  })

  describe('Sequential Calculations', () => {
    it('should handle multiple calculations correctly', async () => {
      // Calculate twice, verify state updates correctly each time
    })
  })
})
```

**Implementation notes:**
- Import from actual composable file path
- Mock ref, readonly, useApi appropriately
- Test all 9 scenarios from TODO
- Verify reactive state updates
- Check error message content (not exact match - use contains/includes)
- Ensure loading state toggles correctly
- Test that calculatePrice throws on error (per implementation)

**Why this structure:**
- Comprehensive coverage of all functionality
- Mocks Nuxt auto-imports via setup.ts
- Tests behavior, not implementation details
- Verifies error handling robustness
  </action>
  <verify>
Run `cd frontend && npm test` - all tests should pass (expect 9+ tests, 0 failures)
  </verify>
  <done>
- usePricingCalculation.spec.ts has 9+ implemented tests
- All test scenarios from TODO covered
- `npm test` passes with 0 failures
- Test coverage includes: initial state, loading, success, errors (400/500/504/generic), reset, sequential calls
- No TODO comments remaining
- TypeScript compilation succeeds
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd frontend && npm test` passes all tests
- [ ] No TypeScript errors in frontend/
- [ ] vitest.config.ts properly configured
- [ ] usePricingCalculation.spec.ts has no TODO comments
- [ ] Test coverage includes all 9 documented scenarios
</verification>

<success_criteria>

- All tasks completed
- Frontend test infrastructure configured (@nuxt/test-utils + Vitest)
- usePricingCalculation composable fully tested (9+ tests passing)
- No test blockers remaining
- Ready for Plan 07-02 (Documentation & Validation)
</success_criteria>

<output>
After completion, create `.planning/phases/07-testing-polish/07-01-SUMMARY.md`:

# Phase 7 Plan 1: Frontend Test Configuration Summary

**[Substantive one-liner describing test setup and coverage]**

## Accomplishments

- Vitest configured with @nuxt/test-utils for Nuxt 3 compatibility
- Auto-import mocking setup in tests/setup.ts
- 9+ comprehensive tests for usePricingCalculation composable
- 100% coverage of composable functionality (calculatePrice, reset, error handling)

## Files Created/Modified

- `frontend/vitest.config.ts` - Vitest configuration
- `frontend/tests/setup.ts` - Auto-import mocking
- `frontend/package.json` - Test dependencies and scripts
- `frontend/tests/unit/usePricingCalculation.spec.ts` - Complete test implementation

## Decisions Made

[Configuration choices, mocking approach, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 07-02-PLAN.md (Documentation & Validation)
</output>
