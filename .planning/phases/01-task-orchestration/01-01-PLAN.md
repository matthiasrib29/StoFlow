---
phase: 01-task-orchestration
plan: 01
type: execute
---

<objective>
Créer le modèle MarketplaceTask minimal et sa migration pour activer le retry intelligent granulaire.

Purpose: Base de données pour tracker l'exécution granulaire des jobs (1 task = 1 étape comme "Upload image 1/3")
Output: Modèle MarketplaceTask avec colonnes minimales + migration réversible multi-tenant
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-phase.md
./01-01-SUMMARY.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/codebase/ARCHITECTURE.md
@backend/models/user/marketplace_task.py (si existe déjà)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Créer/Améliorer modèle MarketplaceTask</name>
  <files>backend/models/user/marketplace_task.py</files>
  <action>
Créer ou améliorer le modèle SQLAlchemy MarketplaceTask avec **colonnes minimales** :

```python
class MarketplaceTask(Base):
    """
    Représente une étape granulaire d'un MarketplaceJob.
    Exemple: "Validate product", "Upload image 1/3", "Create listing"

    Permet retry intelligent: skip les tasks COMPLETED, retry les FAILED.
    """
    __tablename__ = 'marketplace_tasks'

    id: Mapped[int] = mapped_column(primary_key=True)
    job_id: Mapped[int] = mapped_column(ForeignKey('marketplace_jobs.id', ondelete='CASCADE'))

    # Description de la task (free text)
    name: Mapped[str] = mapped_column(String(255), nullable=False)
    # Exemple: "Validate product", "Upload image 1/3", "Create listing on Vinted"

    # Ordre d'exécution dans le job (1, 2, 3, ...)
    position: Mapped[int] = mapped_column(Integer, nullable=False)

    # Statut actuel
    status: Mapped[str] = mapped_column(String(50), nullable=False, default='PENDING')
    # Valeurs: PENDING, RUNNING, COMPLETED, FAILED

    # Résultat JSON de l'exécution (optionnel)
    result: Mapped[Optional[dict]] = mapped_column(JSONB, nullable=True)
    # Exemple pour upload: {"image_id": "vinted_123", "url": "https://..."}
    # Exemple pour validate: {"valid": true, "warnings": []}

    # Message d'erreur si échec
    error_message: Mapped[Optional[str]] = mapped_column(Text, nullable=True)

    # Timestamps
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())
    started_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)
    completed_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)

    # Relation
    job: Mapped["MarketplaceJob"] = relationship(back_populates="tasks")
```

**Index à ajouter:**
- Composite (job_id, position) pour trier les tasks d'un job
- (job_id, status) pour requêtes de retry (trouver les FAILED)

**Imports nécessaires:**
```python
from sqlalchemy import String, Integer, Text, ForeignKey, DateTime, Index
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship
from sqlalchemy.sql import func
from datetime import datetime
from typing import Optional
```

**NE PAS ajouter:**
- ❌ Enum step_type (inutile, le name suffit)
- ❌ Boolean is_idempotent (over-engineering)
- ❌ Colonnes de metadata complexes

**Suivre SQLAlchemy 2.0 patterns** avec Mapped[type] annotations.
  </action>
  <verify>
Tester l'import:
```bash
cd backend
python -c "from models.user.marketplace_task import MarketplaceTask; print('✅ Model OK')"
```
Doit afficher "✅ Model OK" sans erreur.
  </verify>
  <done>
- [ ] Modèle MarketplaceTask créé avec 7 colonnes essentielles
- [ ] Indexes définis: (job_id, position) et (job_id, status)
- [ ] Type hints corrects (Mapped[type])
- [ ] Import Python réussit
- [ ] Relation avec MarketplaceJob définie
  </done>
</task>

<task type="auto">
  <name>Task 2: Créer migration Alembic réversible</name>
  <files>backend/migrations/versions/YYYYMMDD_HHMM_add_marketplace_task_model.py</files>
  <action>
Créer migration Alembic pour ajouter la table marketplace_tasks dans **tous les schemas user_X** (multi-tenant).

**Nom du fichier:** Format timestamp, ex: `20260115_1730_add_marketplace_task_model.py`

**Structure upgrade():**
```python
def upgrade() -> None:
    """Add marketplace_tasks table to all user schemas."""

    # 1. Créer table dans public (schema template)
    op.create_table(
        'marketplace_tasks',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('job_id', sa.Integer(), nullable=False),
        sa.Column('name', sa.String(255), nullable=False),
        sa.Column('position', sa.Integer(), nullable=False),
        sa.Column('status', sa.String(50), nullable=False, server_default='PENDING'),
        sa.Column('result', postgresql.JSONB(), nullable=True),
        sa.Column('error_message', sa.Text(), nullable=True),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
        sa.Column('started_at', sa.DateTime(timezone=True), nullable=True),
        sa.Column('completed_at', sa.DateTime(timezone=True), nullable=True),
        sa.PrimaryKeyConstraint('id'),
        sa.ForeignKeyConstraint(['job_id'], ['marketplace_jobs.id'], ondelete='CASCADE'),
        schema='public'
    )

    # 2. Créer indexes dans public
    op.create_index('ix_marketplace_tasks_job_position', 'marketplace_tasks',
                    ['job_id', 'position'], schema='public')
    op.create_index('ix_marketplace_tasks_job_status', 'marketplace_tasks',
                    ['job_id', 'status'], schema='public')

    # 3. Fan-out vers tous les schemas user_X
    user_schemas = get_user_schemas(op.get_bind())
    for schema in user_schemas:
        # Créer table dans user_X
        op.create_table(
            'marketplace_tasks',
            # ... mêmes colonnes que public ...
            schema=schema
        )
        # Créer indexes dans user_X
        op.create_index(f'ix_marketplace_tasks_job_position', 'marketplace_tasks',
                        ['job_id', 'position'], schema=schema)
        op.create_index(f'ix_marketplace_tasks_job_status', 'marketplace_tasks',
                        ['job_id', 'status'], schema=schema)
```

**Structure downgrade():**
```python
def downgrade() -> None:
    """Drop marketplace_tasks table from all schemas."""

    # 1. Drop depuis tous les user_X schemas
    user_schemas = get_user_schemas(op.get_bind())
    for schema in user_schemas:
        op.drop_index(f'ix_marketplace_tasks_job_status', 'marketplace_tasks', schema=schema)
        op.drop_index(f'ix_marketplace_tasks_job_position', 'marketplace_tasks', schema=schema)
        op.drop_table('marketplace_tasks', schema=schema)

    # 2. Drop depuis public
    op.drop_index('ix_marketplace_tasks_job_status', 'marketplace_tasks', schema='public')
    op.drop_index('ix_marketplace_tasks_job_position', 'marketplace_tasks', schema='public')
    op.drop_table('marketplace_tasks', schema='public')
```

**Helpers à importer:**
```python
from backend.migrations.env import get_user_schemas, table_exists
```

**Commentaire docstring en haut:**
```python
"""
Add marketplace_tasks table for granular job execution tracking.

Enables intelligent retry: skip COMPLETED tasks, retry only FAILED tasks.
Each task represents one step (e.g., "Upload image 1/3", "Create listing").
"""
```

**IMPORTANT:** Migration doit être **réversible** (downgrade fonctionnel).
  </action>
  <verify>
Tester la migration:
```bash
cd backend
# Test upgrade
alembic upgrade head
echo "✅ Upgrade OK"

# Vérifier tables créées
psql $DATABASE_URL -c "SELECT schemaname, tablename FROM pg_tables WHERE tablename='marketplace_tasks';"

# Test reversibilité
alembic downgrade -1
echo "✅ Downgrade OK"

# Reappliquer
alembic upgrade head
```

Toutes les commandes doivent réussir sans erreur.
  </verify>
  <done>
- [ ] Migration créée avec timestamp naming
- [ ] upgrade() crée table + indexes dans public + tous user_X schemas
- [ ] downgrade() drop table + indexes (réversible)
- [ ] Docstring explique le but (retry intelligent)
- [ ] alembic upgrade head fonctionne
- [ ] alembic downgrade -1 fonctionne (reversibilité testée)
- [ ] Tables visibles dans tous les schemas
  </done>
</task>

</tasks>

<verification>
**Tests automatiques:**
- [ ] Python peut importer MarketplaceTask sans erreur
- [ ] `alembic upgrade head` complète sans erreur
- [ ] `alembic downgrade -1` fonctionne (migration réversible)
- [ ] `alembic upgrade head` reapplique correctement

**Vérifications manuelles:**
```bash
# Vérifier structure table
psql $DATABASE_URL -c "\d user_1.marketplace_tasks"

# Doit montrer: id, job_id, name, position, status, result, error_message, timestamps
# Doit montrer: FK vers marketplace_jobs, indexes sur (job_id, position) et (job_id, status)
```

**Checklist:**
- [ ] Table existe dans public ET tous les user_X schemas
- [ ] Colonnes: name, position, status, result, error_message, timestamps
- [ ] Foreign key vers marketplace_jobs avec CASCADE
- [ ] Indexes: (job_id, position) et (job_id, status)
- [ ] Migration réversible (downgrade fonctionne)
</verification>

<success_criteria>
- Modèle MarketplaceTask minimal créé (7 colonnes essentielles)
- Migration réversible appliquée avec succès
- Multi-tenant respecté (table dans tous les schemas)
- Indexes optimisés pour retry intelligent
- Pas de colonnes inutiles (pas de step_type, pas de is_idempotent)
- Prêt pour l'implémentation du TaskOrchestrator (Plan 01-02)
</success_criteria>

<output>
Créer `.planning/phases/01-task-orchestration/01-01-SUMMARY.md` avec:

**Accomplissements:**
- Modèle MarketplaceTask créé avec structure minimale
- Migration YYYYMMDD_HHMM appliquée sur tous les schemas

**Choix techniques:**
- Modèle minimal (name, position, status, result, error_message)
- JSONB result pour flexibilité (pas de schéma strict)
- Indexes sur (job_id, position) et (job_id, status) pour performance

**Révision migration:** [indiquer le hash Alembic]

**Prochaine étape:** Plan 01-02 - Implémentation TaskOrchestrator avec TDD
</output>
