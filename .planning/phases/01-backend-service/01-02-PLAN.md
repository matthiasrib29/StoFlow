---
phase: 01-backend-service
plan: 02
type: execute
---

<objective>
Implémenter les 3 styles de description et la méthode `generate_all()` dans ProductTextGeneratorService.

Purpose: Compléter le service avec génération de descriptions dynamiques adaptées à différents tons (professionnel, storytelling, minimaliste).
Output: Service complet avec `generate_description(product, style)` et `generate_all(product)` fonctionnels.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-phase.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-backend-service/01-01-SUMMARY.md

**Service file from Plan 01:**
@backend/services/product_text_generator.py

**Description Styles (from PROJECT.md):**

**Style 1: Professionnel / E-commerce**
- Ton commercial, phrases fluides
- Structure: intro produit → caractéristiques → état → call-to-action
- Exemple: "Découvrez ce superbe jean Levi's en denim de qualité. Coupe slim flatteuse, taille W32/L34. En très bon état, cette pièce vintage des années 90 ajoutera une touche authentique à votre garde-robe."

**Style 2: Storytelling / Lifestyle**
- Ton narratif, émotionnel, paragraphes
- Structure: accroche lifestyle → histoire du produit → détails → invitation
- Exemple: "Pour les amateurs de mode vintage authentique. Ce jean Levi's des années 90 incarne l'esprit du denim américain. Sa coupe slim et son denim robuste témoignent d'un savoir-faire intemporel..."

**Style 3: Minimaliste / Fiche Technique**
- Liste structurée, scan rapide
- Format: bullet points avec catégories
- Exemple:
  ```
  • Marque: Levi's
  • Type: Jean
  • Taille: W32/L34
  • Couleur: Blue
  • Matière: Denim
  • Coupe: Slim
  • État: Très bon état
  • Époque: 90s
  ```

**Constraints:**
- Max 5000 caractères pour description
- Gestion intelligente des attributs manquants (skip les phrases/lignes concernées)
- Français correct (accords basiques)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement generate_description() with 3 styles</name>
  <files>backend/services/product_text_generator.py</files>
  <action>
Add DescriptionStyle enum and generate_description() method:

1. **DescriptionStyle enum**: PROFESSIONAL=1, STORYTELLING=2, MINIMALIST=3

2. **generate_description()** method:
```python
@staticmethod
def generate_description(product: Product, style: DescriptionStyle = DescriptionStyle.PROFESSIONAL) -> str:
    """
    Generate dynamic description for a product.

    Args:
        product: Product model instance
        style: DescriptionStyle enum (1=Professional, 2=Storytelling, 3=Minimalist)

    Returns:
        Description string (max 5000 chars), segments with missing attributes removed
    """
```

**Style 1 (Professionnel)** - Build flowing sentences:
- Intro: "Découvrez ce/cette {category} {brand}..." (skip brand if missing)
- Caractéristiques: material, fit, size (only if present)
- État: "En {condition_text}..." with condition_sup details if available
- Origine/époque: decade, origin if present
- Call-to-action: "Une pièce {trend} à ne pas manquer." (only if trend exists)

**Style 2 (Storytelling)** - Build narrative paragraphs:
- Accroche: "Pour les amateurs de {trend/style}..." or generic if missing
- Histoire: "Ce/Cette {category} {brand} {decade}..."
- Détails: material quality, fit description, unique features
- Invitation: "Adoptez ce style {season}..." if season exists

**Style 3 (Minimaliste)** - Build bullet list:
- Only include lines where attribute exists
- Format: "• {Label}: {value}"
- Order: Marque, Type, Genre, Taille, Couleur(s), Matière, Coupe, Taille haute/basse, Fermeture, Motif, État, Détails état, Caractéristiques, Tendance, Saison, Origine, Époque

**Implementation helpers:**
- `_build_professional_description(product) -> str`
- `_build_storytelling_description(product) -> str`
- `_build_minimalist_description(product) -> str`

Each helper builds only segments where attributes exist. Use list of segments, filter None/empty, join appropriately.
  </action>
  <verify>
cd backend && python -c "
from services.product_text_generator import ProductTextGeneratorService, DescriptionStyle

class MockProduct:
    brand = 'Levi\\'s'
    category = 'jeans'
    gender = 'Men'
    size_normalized = 'W32/L34'
    colors = ['Blue']
    material = 'Denim'
    fit = 'Slim'
    condition = 7
    decade = '90s'
    rise = 'Mid-rise'
    closure = 'Button fly'
    unique_feature = ['Selvedge']
    pattern = None
    trend = 'Vintage'
    season = 'All seasons'
    origin = 'USA'
    condition_sup = ['Vintage wear']
    stretch = None
    length = None
    neckline = None
    sleeve_length = None
    lining = None
    sport = None

p = MockProduct()

# Test all 3 styles
for style in DescriptionStyle:
    desc = ProductTextGeneratorService.generate_description(p, style)
    print(f'\\n=== {style.name} ({len(desc)} chars) ===')
    print(desc[:200] + '...' if len(desc) > 200 else desc)
    assert len(desc) <= 5000, f'{style.name} too long'
    assert 'None' not in desc, f'None found in {style.name}'

print('\\nAll styles OK')
"
  </verify>
  <done>generate_description() works for all 3 styles. Handles missing attributes gracefully. No "None" in output.</done>
</task>

<task type="auto">
  <name>Task 2: Implement generate_all() and finalize service</name>
  <files>backend/services/product_text_generator.py</files>
  <action>
Add generate_all() method and ensure service is complete:

1. **generate_all()** method:
```python
@staticmethod
def generate_all(product: Product) -> dict:
    """
    Generate all title formats and description styles for a product.

    Args:
        product: Product model instance

    Returns:
        dict with structure:
        {
            "titles": {
                "ultra_complete": "...",
                "technical": "...",
                "style_trend": "..."
            },
            "descriptions": {
                "professional": "...",
                "storytelling": "...",
                "minimalist": "..."
            }
        }
    """
```

2. **Add preview method** for generating from raw attributes (no Product model):
```python
@staticmethod
def generate_preview(attributes: dict) -> dict:
    """
    Generate preview from raw attributes dict (for form preview before save).

    Args:
        attributes: dict with product attributes (brand, category, colors, etc.)

    Returns:
        Same structure as generate_all()
    """
```
This creates a simple object with attributes from dict and calls generate_all().

3. **Ensure all imports are correct** and service is ready for API integration.

4. **Add module docstring** explaining the service purpose and usage.
  </action>
  <verify>
cd backend && python -c "
from services.product_text_generator import ProductTextGeneratorService

class MockProduct:
    brand = 'Levi\\'s'
    category = 'jeans'
    gender = 'Men'
    size_normalized = 'W32/L34'
    colors = ['Blue', 'White']
    material = 'Denim'
    fit = 'Slim'
    condition = 8
    decade = '90s'
    rise = None
    closure = None
    unique_feature = None
    pattern = None
    trend = 'Vintage'
    season = None
    origin = None
    condition_sup = None
    stretch = None
    length = None
    neckline = None
    sleeve_length = None
    lining = None
    sport = None

# Test generate_all
result = ProductTextGeneratorService.generate_all(MockProduct())
print('Keys:', result.keys())
print('Title keys:', result['titles'].keys())
print('Desc keys:', result['descriptions'].keys())
assert 'titles' in result
assert 'descriptions' in result
assert len(result['titles']) == 3
assert len(result['descriptions']) == 3

# Test generate_preview
preview = ProductTextGeneratorService.generate_preview({
    'brand': 'Nike',
    'category': 't-shirt',
    'colors': ['Black'],
    'condition': 9
})
print('\\nPreview titles:', list(preview['titles'].keys()))
assert 'titles' in preview

print('\\nAll methods OK')
"
  </verify>
  <done>generate_all() and generate_preview() work. Service is complete and ready for API integration.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] DescriptionStyle enum has 3 values
- [ ] generate_description() works for all 3 styles
- [ ] generate_all() returns dict with titles and descriptions
- [ ] generate_preview() works with raw attributes dict
- [ ] No "None" strings in any output
- [ ] All descriptions ≤5000 chars
- [ ] Service file has proper docstring and follows conventions
</verification>

<success_criteria>
- DescriptionStyle enum with 3 styles
- generate_description(product, style) works for all styles
- generate_all(product) returns complete dict
- generate_preview(attributes) works for form preview
- All outputs are clean (no None, proper formatting)
- Phase 1 complete - service ready for API integration (Phase 2)
</success_criteria>

<output>
After completion, create `.planning/phases/01-backend-service/01-02-SUMMARY.md` with:
- Phase 1 complete status
- Ready for Phase 2 (Backend API)
</output>
