---
phase: 06-frontend-ui
plan: 01
type: execute
---

<objective>
Create pricing composable and integrate with product pages for price calculation.

Purpose: Enable users to trigger intelligent pricing calculations from the product interface with proper state management and error handling.

Output: Working usePricing composable integrated into product detail/form pages with loading and error states.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-phase.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-main-pricing-algorithm/05-01-SUMMARY.md
@.planning/phases/05-main-pricing-algorithm/05-02-SUMMARY.md
@.planning/phases/05-main-pricing-algorithm/05-03-SUMMARY.md

**Phase dependencies:**
- Phase 5 complete: POST /api/pricing/calculate endpoint available
- Schemas: PriceInput, PriceOutput, AdjustmentBreakdown
- Error handling: 400 (validation), 500 (generation), 504 (timeout)

**Tech stack available:**
- Nuxt.js 3 with Composition API
- TypeScript
- Pinia for state management (optional)
- Existing composables: useApi.ts (API client with JWT)
- Tailwind CSS for styling

**Established patterns:**
- Composables in `frontend/composables/`
- Auto-imported components
- API calls via useApi composable
- Error handling with toast notifications
- Loading states with reactive refs

**Key files to reference:**
- `frontend/composables/useApi.ts` - API client pattern
- `frontend/composables/useProductAttributes.ts` - Example composable
- `frontend/pages/dashboard/products/[id].vue` - Product detail page
- `backend/schemas/pricing.py` - API schemas (for TypeScript types)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create usePricing composable with API integration</name>
  <files>frontend/composables/usePricing.ts</files>
  <action>
    Create `usePricing.ts` composable with the following:

    **TypeScript interfaces (matching backend schemas):**
    ```typescript
    interface PriceInput {
      brand: string
      category: string
      materials: string[]
      model_name?: string
      condition_score: number  // 0-5
      supplements: string[]
      condition_sensitivity: number  // 0.5-1.5
      actual_origin: string
      expected_origins: string[]
      actual_decade: string
      expected_decades: string[]
      actual_trends: string[]
      expected_trends: string[]
      actual_features: string[]
      expected_features: string[]
    }

    interface AdjustmentBreakdown {
      condition: number
      origin: number
      decade: number
      trend: number
      feature: number
      total: number
    }

    interface PriceOutput {
      quick_price: string
      standard_price: string
      premium_price: string
      base_price: string
      model_coefficient: number
      adjustments: AdjustmentBreakdown
      brand: string
      group: string
      model_name?: string
    }
    ```

    **Composable function:**
    ```typescript
    export const usePricing = () => {
      const api = useApi()
      const isLoading = ref(false)
      const error = ref<string | null>(null)
      const priceResult = ref<PriceOutput | null>(null)

      const calculatePrice = async (input: PriceInput) => {
        isLoading.value = true
        error.value = null
        priceResult.value = null

        try {
          const response = await api.post('/pricing/calculate', input)
          priceResult.value = response.data
          return response.data
        } catch (err: any) {
          // Handle different error types
          if (err.response?.status === 400) {
            error.value = 'Invalid product data. Please check all fields.'
          } else if (err.response?.status === 504) {
            error.value = 'Pricing calculation timed out. Please try again.'
          } else if (err.response?.status === 500) {
            error.value = 'Failed to generate pricing data. Please try again later.'
          } else {
            error.value = err.response?.data?.detail || 'An error occurred during price calculation'
          }
          throw err
        } finally {
          isLoading.value = false
        }
      }

      const reset = () => {
        priceResult.value = null
        error.value = null
      }

      return {
        isLoading: readonly(isLoading),
        error: readonly(error),
        priceResult: readonly(priceResult),
        calculatePrice,
        reset
      }
    }
    ```

    **Why this approach:**
    - Matches existing composable patterns (useApi, useProductAttributes)
    - TypeScript interfaces match backend Pydantic schemas exactly
    - Reactive state with refs for loading, error, result
    - Granular error handling based on HTTP status codes
    - Reset function for clearing state
    - Readonly exports prevent external mutation
  </action>
  <verify>
    1. TypeScript compilation succeeds: `npm run type-check` (if available) or build passes
    2. Composable can be imported: `import { usePricing } from '~/composables/usePricing'`
    3. No linting errors
    4. Interfaces match backend schemas
  </verify>
  <done>
    - usePricing.ts exists with calculatePrice, reset functions
    - TypeScript interfaces defined for PriceInput, PriceOutput, AdjustmentBreakdown
    - Reactive state management (isLoading, error, priceResult)
    - Error handling for 400/500/504 status codes
    - No TypeScript or linting errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate pricing button into product detail page</name>
  <files>frontend/pages/dashboard/products/[id].vue</files>
  <action>
    Add pricing calculation feature to the product detail page:

    **1. Import composable:**
    ```typescript
    const { isLoading, error, priceResult, calculatePrice, reset } = usePricing()
    ```

    **2. Add "Calculate Price" button in appropriate section** (likely near product attributes or actions):
    ```vue
    <template>
      <!-- Existing product detail content -->

      <!-- Pricing Section -->
      <div class="mt-6 p-4 border border-gray-200 rounded-lg">
        <h3 class="text-lg font-semibold mb-3">Intelligent Pricing</h3>

        <button
          @click="handleCalculatePrice"
          :disabled="isLoading || !canCalculatePrice"
          class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          <span v-if="!isLoading">Calculate Price</span>
          <span v-else class="flex items-center">
            <svg class="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
              <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
              <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            Calculating...
          </span>
        </button>

        <!-- Error Message -->
        <div v-if="error" class="mt-3 p-3 bg-red-50 border border-red-200 rounded-md text-red-700 text-sm">
          {{ error }}
        </div>

        <!-- Pricing result will be displayed by PricingDisplay component in Plan 06-02 -->
        <div v-if="priceResult" class="mt-4">
          <!-- Placeholder for PricingDisplay component (Plan 06-02) -->
          <p class="text-sm text-gray-600">Price calculated successfully. Display component coming in next plan.</p>
          <pre class="mt-2 p-2 bg-gray-100 rounded text-xs overflow-auto">{{ priceResult }}</pre>
        </div>
      </div>
    </template>
    ```

    **3. Implement handleCalculatePrice method:**
    ```typescript
    const handleCalculatePrice = async () => {
      if (!product.value) return

      // Build PriceInput from product data
      const input: PriceInput = {
        brand: product.value.brand || '',
        category: product.value.category || '',
        materials: product.value.materials || [],
        model_name: product.value.model,
        condition_score: product.value.condition_score || 3,
        supplements: product.value.supplements || [],
        condition_sensitivity: 1.0,
        actual_origin: product.value.origin || 'Unknown',
        expected_origins: [], // TODO: determine from category/brand
        actual_decade: product.value.decade || '2020s',
        expected_decades: [],
        actual_trends: product.value.trends || [],
        expected_trends: [],
        actual_features: product.value.features || [],
        expected_features: []
      }

      try {
        await calculatePrice(input)
      } catch (err) {
        // Error already handled in composable
        console.error('Price calculation failed:', err)
      }
    }

    const canCalculatePrice = computed(() => {
      return product.value?.brand && product.value?.category
    })
    ```

    **Why this approach:**
    - Minimal invasive changes to existing product detail page
    - Button disabled during loading and if required data missing
    - Loading spinner provides clear feedback
    - Error messages displayed inline
    - Placeholder for PricingDisplay component (Plan 06-02)
    - Uses product data to build PriceInput
  </action>
  <verify>
    1. Page loads without errors
    2. "Calculate Price" button visible on product detail page
    3. Button disabled when loading or required data missing
    4. Clicking button triggers API call (check network tab)
    5. Loading spinner shows during calculation
    6. Error messages display for failed calculations
    7. Success shows pricing result (temporary display)
  </verify>
  <done>
    - Product detail page updated with pricing section
    - "Calculate Price" button integrated with loading states
    - handleCalculatePrice method builds PriceInput from product
    - Error handling displays user-friendly messages
    - Loading spinner visible during calculation
    - Can calculate price successfully and see result
  </done>
</task>

<task type="auto">
  <name>Task 3: Add basic unit tests for usePricing composable</name>
  <files>frontend/tests/composables/usePricing.spec.ts</files>
  <action>
    Create unit tests for the usePricing composable (if test setup exists):

    **Test structure:**
    ```typescript
    import { describe, it, expect, beforeEach, vi } from 'vitest'
    import { usePricing } from '~/composables/usePricing'

    // Mock useApi
    vi.mock('~/composables/useApi', () => ({
      useApi: () => ({
        post: vi.fn()
      })
    }))

    describe('usePricing', () => {
      beforeEach(() => {
        vi.clearAllMocks()
      })

      it('should initialize with default state', () => {
        const { isLoading, error, priceResult } = usePricing()

        expect(isLoading.value).toBe(false)
        expect(error.value).toBeNull()
        expect(priceResult.value).toBeNull()
      })

      it('should set loading state during calculation', async () => {
        const { isLoading, calculatePrice } = usePricing()
        const mockInput = { /* valid PriceInput */ }

        const promise = calculatePrice(mockInput)
        expect(isLoading.value).toBe(true)

        await promise
        expect(isLoading.value).toBe(false)
      })

      it('should handle successful price calculation', async () => {
        const mockResult = {
          quick_price: '75.00',
          standard_price: '100.00',
          premium_price: '130.00',
          // ... other fields
        }

        // Mock successful API response
        const { priceResult, calculatePrice } = usePricing()
        await calculatePrice({/* input */})

        expect(priceResult.value).toEqual(mockResult)
      })

      it('should handle 400 validation error', async () => {
        // Mock API error
        const { error, calculatePrice } = usePricing()

        await expect(calculatePrice({/* input */})).rejects.toThrow()
        expect(error.value).toContain('Invalid product data')
      })

      it('should handle 504 timeout error', async () => {
        const { error, calculatePrice } = usePricing()

        await expect(calculatePrice({/* input */})).rejects.toThrow()
        expect(error.value).toContain('timed out')
      })

      it('should reset state', () => {
        const { priceResult, error, reset } = usePricing()

        // Set some state
        priceResult.value = {/* result */}
        error.value = 'Some error'

        reset()

        expect(priceResult.value).toBeNull()
        expect(error.value).toBeNull()
      })
    })
    ```

    **If test framework not set up:**
    Skip this task and add comment in code: `// TODO: Add tests when Vitest configured`

    **Why tests:**
    - Validate state management logic
    - Ensure error handling works correctly
    - Prevent regressions in future changes
    - Document expected behavior
  </action>
  <verify>
    If tests created:
    - `npm run test` passes (or equivalent)
    - All test cases pass
    - No console errors

    If skipped:
    - Comment added to usePricing.ts about pending tests
  </verify>
  <done>
    - Unit tests created for usePricing composable (if framework exists)
    - Tests cover: initialization, loading states, success, errors, reset
    - All tests passing
    - OR: TODO comment added if test framework not available
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] usePricing composable exists and exports correct functions
- [ ] TypeScript types defined and match backend schemas
- [ ] Product detail page has "Calculate Price" button
- [ ] Button triggers API call to /pricing/calculate
- [ ] Loading states work correctly
- [ ] Error messages display for different error types
- [ ] Price result displays (temporary, will be replaced in Plan 06-02)
- [ ] No TypeScript or build errors
</verification>

<success_criteria>

- All tasks completed
- usePricing composable functional with state management
- Product detail page integrated with pricing button
- Loading and error states working
- API integration successful
- Ready for Plan 06-02 (PricingDisplay component)
</success_criteria>

<output>
After completion, create `.planning/phases/06-frontend-ui/06-01-SUMMARY.md`:

# Phase 6 Plan 1: Pricing Composable & API Integration Summary

**[Substantive one-liner describing the composable and API integration]**

## Accomplishments

- usePricing composable with state management
- API integration with error handling (400/500/504)
- Product detail page with "Calculate Price" button
- Loading states and error messages
- TypeScript interfaces matching backend schemas

## Files Created/Modified

- `frontend/composables/usePricing.ts` - Pricing composable
- `frontend/pages/dashboard/products/[id].vue` - Integrated pricing button
- `frontend/tests/composables/usePricing.spec.ts` - Unit tests (if applicable)

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 06-02-PLAN.md (PricingDisplay Component)
</output>
