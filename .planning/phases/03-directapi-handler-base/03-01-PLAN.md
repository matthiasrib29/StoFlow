---
phase: 03-directapi-handler-base
plan: 03-01
type: execute
---

<objective>
Create DirectAPIJobHandler base class to eliminate 80%+ code duplication between eBay and Etsy job handlers.

Extract common patterns (product validation, service delegation, result handling, exception handling) into a reusable base class that both eBay and Etsy handlers will inherit from in Phase 4+.
</objective>

<execution_context>
@backend/services/vinted/jobs/base_job_handler.py
@backend/services/ebay/jobs/ebay_publish_job_handler.py
@backend/services/etsy/jobs/etsy_publish_job_handler.py
@backend/services/ebay/jobs/ebay_update_job_handler.py
@backend/services/etsy/jobs/etsy_update_job_handler.py
@backend/services/ebay/jobs/ebay_delete_job_handler.py
@backend/services/etsy/jobs/etsy_delete_job_handler.py
@.planning/phases/02-base-handler-unification/02-01-SUMMARY.md
@.planning/phases/01-task-orchestration/01-02-SUMMARY.md
</execution_context>

<context>
## Current State

**Problem**: 10 handlers (5 eBay + 5 Etsy) share ~80% identical code:
- `EbayPublishJobHandler` vs `EtsyPublishJobHandler` → 95% identical (81 lines)
- `EbayUpdateJobHandler` vs `EtsyUpdateJobHandler` → 95% identical (79 lines)
- `EbayDeleteJobHandler` vs `EtsyDeleteJobHandler` → 95% identical (similar pattern)
- Sync and orders handlers follow same pattern

**Common Pattern Identified** (from discovery analysis):

```python
# Every eBay/Etsy handler follows this structure:
async def execute(self, job: MarketplaceJob) -> dict[str, Any]:
    # 1. Validate product_id required
    if not product_id:
        self.log_error("product_id is required")
        return {"success": False, "error": "product_id required"}

    # 2. Log start
    self.log_start(f"<Action> product {product_id} to <Marketplace>")

    try:
        # 3. Instantiate marketplace-specific service
        service = <EbayPublicationService|EtsyPublicationService>(self.db)

        # 4. Call action-specific method
        result = await service.<action_method>(product_id)

        # 5. Handle success/error result
        if result.get("success", False):
            listing_id = result.get("<marketplace>_listing_id", "unknown")
            self.log_success(f"<Action> product {product_id} → listing {listing_id}")
        else:
            error_msg = result.get("error", "Unknown error")
            self.log_error(f"Failed to <action> product {product_id}: {error_msg}")

        return result

    except Exception as e:
        # 6. Exception handling
        error_msg = f"Exception <action> product {product_id}: {e}"
        self.log_error(error_msg, exc_info=True)
        return {"success": False, "error": str(e)}
```

**Only 3 things vary**:
1. Service class name (`EbayPublicationService` vs `EtsyPublicationService`)
2. Service method name (`publish_product`, `update_product`, `delete_product`, etc.)
3. Result field names (`ebay_listing_id` vs `etsy_listing_id`)

## Goal

Create `DirectAPIJobHandler` abstract base class that:
- Extends `BaseJobHandler` (Phase 2)
- Implements the common execute pattern
- Requires subclasses to provide: `get_service()`, `get_service_method_name()`
- Handles product validation, logging, and exception handling automatically

## Architecture Target

```
BaseJobHandler (Phase 2)
    ↑
DirectAPIJobHandler (NEW - Phase 3)
    ↑
    ├── EbayPublishJobHandler (refactored in Phase 4)
    ├── EtsyPublishJobHandler (refactored in Phase 4)
    ├── EbayUpdateJobHandler (refactored in Phase 4)
    └── ... (8 more handlers to be refactored)
```

## Out of Scope

- **Vinted handlers**: Use WebSocket plugin, different architecture (will stay with BaseJobHandler)
- **Actual handler migrations**: Phase 4+ will migrate eBay/Etsy handlers to use DirectAPIJobHandler
- **Service refactoring**: Services (EbayPublicationService, EtsyPublicationService) stay unchanged
- **Task orchestration integration**: Phase 5+ will add `create_tasks()` implementations
</context>

<tasks>
  <task type="auto">
    <instruction>
Create DirectAPIJobHandler base class with common execution pattern.

**File**: `backend/services/marketplace/direct_api_job_handler.py` (NEW)

**Implementation**:

```python
"""
DirectAPIJobHandler - Base class for direct marketplace API handlers (eBay, Etsy)

Factorizes common patterns:
- Product validation
- Service instantiation and delegation
- Result handling and logging
- Exception handling

Subclasses must implement:
- get_service(): Returns marketplace-specific service instance
- get_service_method_name(): Returns method name to call on service

Author: Claude
Date: 2026-01-15
Phase: 03-directapi-handler-base
"""

from abc import abstractmethod
from typing import Any

from sqlalchemy.orm import Session

from models.user.marketplace_job import MarketplaceJob
from models.user.product import Product
from services.vinted.jobs.base_job_handler import BaseJobHandler
from shared.logging_setup import get_logger

logger = get_logger(__name__)


class DirectAPIJobHandler(BaseJobHandler):
    """
    Abstract base class for handlers that call marketplace APIs directly.

    Used by eBay and Etsy handlers (not Vinted, which uses WebSocket plugin).

    Provides common workflow:
    1. Validate product_id exists
    2. Get marketplace-specific service (abstract)
    3. Call action-specific method on service (abstract)
    4. Handle result with logging
    5. Handle exceptions uniformly

    Subclasses must implement:
        get_service() -> marketplace-specific service instance
        get_service_method_name() -> method name to call (e.g., "publish_product")

    Example:
        class EbayPublishJobHandler(DirectAPIJobHandler):
            ACTION_CODE = "publish_ebay"

            def get_service(self):
                return EbayPublicationService(self.db)

            def get_service_method_name(self) -> str:
                return "publish_product"

            def create_tasks(self, job: MarketplaceJob) -> List[str]:
                return ["Validate product", "Publish to eBay", "Save result"]
    """

    @abstractmethod
    def get_service(self) -> Any:
        """
        Return marketplace-specific service instance.

        Examples:
            - EbayPublicationService(self.db)
            - EtsyPublicationService(self.db)

        Returns:
            Service instance with methods like publish_product(), update_product(), etc.
        """
        pass

    @abstractmethod
    def get_service_method_name(self) -> str:
        """
        Return name of the method to call on the service.

        Examples:
            - "publish_product"
            - "update_product"
            - "delete_product"

        Returns:
            Method name as string
        """
        pass

    async def execute(self, job: MarketplaceJob) -> dict[str, Any]:
        """
        Execute marketplace API operation using service delegation pattern.

        Workflow:
        1. Validate product_id exists
        2. Log start
        3. Get service and call method
        4. Handle success/error
        5. Handle exceptions

        Args:
            job: MarketplaceJob with product_id

        Returns:
            dict: {
                "success": bool,
                "<marketplace>_listing_id": str (if success),
                "error": str (if failure)
            }
        """
        product_id = job.product_id

        # 1. Validate product_id required
        if not product_id:
            self.log_error("product_id is required")
            return {"success": False, "error": "product_id required"}

        # 2. Log start
        method_name = self.get_service_method_name()
        self.log_start(f"Executing {method_name} for product {product_id}")

        try:
            # 3. Get service and call method
            service = self.get_service()
            method = getattr(service, method_name)
            result = await method(product_id)

            # 4. Handle success/error
            if result.get("success", False):
                # Log success with listing_id (generic handling)
                listing_id = result.get("ebay_listing_id") or result.get("etsy_listing_id") or "unknown"
                self.log_success(
                    f"Executed {method_name} for product {product_id} → "
                    f"listing {listing_id}"
                )
            else:
                error_msg = result.get("error", "Unknown error")
                self.log_error(f"Failed {method_name} for product {product_id}: {error_msg}")

            return result

        except Exception as e:
            # 5. Exception handling
            error_msg = f"Exception in {method_name} for product {product_id}: {e}"
            self.log_error(error_msg, exc_info=True)
            return {"success": False, "error": str(e)}
```

**Verification**:
- [ ] File created at `backend/services/marketplace/direct_api_job_handler.py`
- [ ] Extends `BaseJobHandler`
- [ ] Defines two abstract methods: `get_service()`, `get_service_method_name()`
- [ ] Implements common `execute()` pattern with 5 steps
- [ ] Handles product_id validation
- [ ] Logs start/success/error appropriately
- [ ] Exception handling returns standardized error dict
- [ ] Docstrings include examples for subclasses
- [ ] Type hints complete
    </instruction>
  </task>

  <task type="auto">
    <instruction>
Add example implementation documentation showing how to use DirectAPIJobHandler.

**File**: `backend/services/marketplace/direct_api_job_handler.py` (APPEND)

**Add to module docstring** (top of file, after the existing docstring):

```python
# ... existing module docstring ...

Usage Example:
==============

Before (Duplicated Code - 81 lines per handler):
```python
class EbayPublishJobHandler(BaseJobHandler):
    ACTION_CODE = "publish_ebay"

    async def execute(self, job: MarketplaceJob) -> dict[str, Any]:
        product_id = job.product_id

        if not product_id:
            self.log_error("product_id is required")
            return {"success": False, "error": "product_id required"}

        self.log_start(f"Publishing product {product_id} to eBay")

        try:
            service = EbayPublicationService(self.db)
            result = await service.publish_product(product_id)

            if result.get("success", False):
                ebay_listing_id = result.get("ebay_listing_id", "unknown")
                self.log_success(f"Published product {product_id} → eBay listing {ebay_listing_id}")
            else:
                error_msg = result.get("error", "Unknown error")
                self.log_error(f"Failed to publish product {product_id}: {error_msg}")

            return result

        except Exception as e:
            error_msg = f"Exception publishing product {product_id}: {e}"
            self.log_error(error_msg, exc_info=True)
            return {"success": False, "error": str(e)}

    def create_tasks(self, job: MarketplaceJob) -> List[str]:
        return ["Validate", "Publish", "Save"]
```

After (Using DirectAPIJobHandler - 15 lines per handler):
```python
class EbayPublishJobHandler(DirectAPIJobHandler):
    ACTION_CODE = "publish_ebay"

    def get_service(self):
        from services.ebay.ebay_publication_service import EbayPublicationService
        return EbayPublicationService(self.db)

    def get_service_method_name(self) -> str:
        return "publish_product"

    def create_tasks(self, job: MarketplaceJob) -> List[str]:
        return ["Validate", "Publish", "Save"]
```

Result: **81% reduction in code** (81 lines → 15 lines = 66 lines saved per handler × 10 handlers = 660 lines total)
"""
```

**Verification**:
- [ ] Usage examples added to module docstring
- [ ] Shows before/after comparison
- [ ] Includes concrete metrics (81% reduction, 660 lines saved)
- [ ] Examples are correct and would work if copy-pasted
    </instruction>
  </task>

  <task type="auto">
    <instruction>
Write comprehensive tests for DirectAPIJobHandler (test-after pragmatic approach).

**File**: `backend/tests/unit/services/test_direct_api_job_handler.py` (NEW)

**Test Coverage**:

```python
"""
Unit Tests for DirectAPIJobHandler

Tests the base class functionality that will be used by eBay/Etsy handlers.

Created: 2026-01-15
Phase: 03-directapi-handler-base
"""

import pytest
from unittest.mock import Mock, AsyncMock, patch
from datetime import datetime, timezone

from models.user.marketplace_job import MarketplaceJob, JobStatus
from services.marketplace.direct_api_job_handler import DirectAPIJobHandler
from shared.logging_setup import get_logger

logger = get_logger(__name__)


# ===== TEST HANDLER IMPLEMENTATION =====

class ConcreteDirectAPIHandler(DirectAPIJobHandler):
    """
    Concrete implementation for testing DirectAPIJobHandler.

    Simulates an eBay-like handler.
    """

    ACTION_CODE = "test_direct_api"

    def __init__(self, db, shop_id=None, job_id=None, mock_service=None):
        super().__init__(db, shop_id, job_id)
        self._mock_service = mock_service

    def get_service(self):
        """Return mocked service."""
        return self._mock_service

    def get_service_method_name(self) -> str:
        """Return test method name."""
        return "test_action"

    def create_tasks(self, job: MarketplaceJob) -> list[str]:
        """Return test tasks."""
        return ["Task 1", "Task 2", "Task 3"]


# ===== FIXTURES =====

@pytest.fixture
def db_session():
    """Mock database session."""
    return Mock(spec=["query", "add", "flush", "commit", "rollback", "refresh"])


@pytest.fixture
def sample_job():
    """Sample MarketplaceJob."""
    return MarketplaceJob(
        id=1,
        marketplace="ebay",
        action_type_id=1,
        product_id=101,
        status=JobStatus.PENDING,
        priority=3,
        retry_count=0,
        max_retries=3,
        created_at=datetime.now(timezone.utc)
    )


@pytest.fixture
def mock_service():
    """Mock marketplace service."""
    service = Mock()
    service.test_action = AsyncMock()
    return service


@pytest.fixture
def handler(db_session, mock_service):
    """Instantiate test handler."""
    return ConcreteDirectAPIHandler(
        db=db_session,
        shop_id=123,
        job_id=1,
        mock_service=mock_service
    )


# ===== TESTS =====

class TestDirectAPIJobHandlerValidation:
    """Tests for product_id validation."""

    @pytest.mark.asyncio
    async def test_execute_fails_if_no_product_id(self, handler, sample_job):
        """Should return error if product_id is None."""
        sample_job.product_id = None

        result = await handler.execute(sample_job)

        assert result["success"] is False
        assert "product_id required" in result["error"]

    @pytest.mark.asyncio
    async def test_execute_validates_product_id_before_service_call(self, handler, sample_job, mock_service):
        """Should validate product_id before calling service."""
        sample_job.product_id = None

        result = await handler.execute(sample_job)

        # Service should NOT be called if validation fails
        mock_service.test_action.assert_not_called()
        assert result["success"] is False


class TestDirectAPIJobHandlerServiceDelegation:
    """Tests for service instantiation and delegation."""

    @pytest.mark.asyncio
    async def test_execute_calls_service_method(self, handler, sample_job, mock_service):
        """Should call the method returned by get_service_method_name()."""
        mock_service.test_action.return_value = {"success": True, "ebay_listing_id": "12345"}

        result = await handler.execute(sample_job)

        # Verify service method was called with correct product_id
        mock_service.test_action.assert_called_once_with(101)

    @pytest.mark.asyncio
    async def test_execute_uses_get_service_method(self, handler, sample_job, mock_service):
        """Should instantiate service via get_service()."""
        mock_service.test_action.return_value = {"success": True}

        await handler.execute(sample_job)

        # Verify get_service() was used (service is our mock)
        assert handler.get_service() == mock_service

    @pytest.mark.asyncio
    async def test_execute_returns_service_result(self, handler, sample_job, mock_service):
        """Should return the exact result from service method."""
        expected_result = {
            "success": True,
            "ebay_listing_id": "12345",
            "ebay_sku": "SKU-101"
        }
        mock_service.test_action.return_value = expected_result

        result = await handler.execute(sample_job)

        assert result == expected_result


class TestDirectAPIJobHandlerResultHandling:
    """Tests for success/error result handling."""

    @pytest.mark.asyncio
    async def test_execute_handles_success_result(self, handler, sample_job, mock_service):
        """Should handle success result with listing_id."""
        mock_service.test_action.return_value = {
            "success": True,
            "ebay_listing_id": "eBay-12345"
        }

        result = await handler.execute(sample_job)

        assert result["success"] is True
        assert result["ebay_listing_id"] == "eBay-12345"

    @pytest.mark.asyncio
    async def test_execute_handles_etsy_listing_id(self, handler, sample_job, mock_service):
        """Should handle Etsy-style listing_id field."""
        mock_service.test_action.return_value = {
            "success": True,
            "etsy_listing_id": "Etsy-67890"
        }

        result = await handler.execute(sample_job)

        assert result["success"] is True
        assert result["etsy_listing_id"] == "Etsy-67890"

    @pytest.mark.asyncio
    async def test_execute_handles_service_error(self, handler, sample_job, mock_service):
        """Should handle error result from service."""
        mock_service.test_action.return_value = {
            "success": False,
            "error": "API rate limit exceeded"
        }

        result = await handler.execute(sample_job)

        assert result["success"] is False
        assert result["error"] == "API rate limit exceeded"


class TestDirectAPIJobHandlerExceptionHandling:
    """Tests for exception handling."""

    @pytest.mark.asyncio
    async def test_execute_catches_service_exception(self, handler, sample_job, mock_service):
        """Should catch and handle exceptions from service."""
        mock_service.test_action.side_effect = ValueError("Invalid product data")

        result = await handler.execute(sample_job)

        assert result["success"] is False
        assert "Invalid product data" in result["error"]

    @pytest.mark.asyncio
    async def test_execute_catches_network_exception(self, handler, sample_job, mock_service):
        """Should catch network/timeout exceptions."""
        mock_service.test_action.side_effect = TimeoutError("API timeout")

        result = await handler.execute(sample_job)

        assert result["success"] is False
        assert "API timeout" in result["error"]

    @pytest.mark.asyncio
    async def test_execute_returns_standardized_error_dict(self, handler, sample_job, mock_service):
        """Should always return dict with success=False and error on exception."""
        mock_service.test_action.side_effect = RuntimeError("Unexpected error")

        result = await handler.execute(sample_job)

        assert isinstance(result, dict)
        assert "success" in result
        assert result["success"] is False
        assert "error" in result
        assert isinstance(result["error"], str)


class TestDirectAPIJobHandlerAbstractMethods:
    """Tests for abstract method enforcement."""

    def test_cannot_instantiate_without_get_service(self, db_session):
        """Should raise TypeError if get_service() not implemented."""

        class IncompleteHandler(DirectAPIJobHandler):
            ACTION_CODE = "incomplete"

            def get_service_method_name(self) -> str:
                return "test"

            def create_tasks(self, job):
                return []

        with pytest.raises(TypeError, match="Can't instantiate abstract class"):
            IncompleteHandler(db=db_session, shop_id=123, job_id=1)

    def test_cannot_instantiate_without_get_service_method_name(self, db_session):
        """Should raise TypeError if get_service_method_name() not implemented."""

        class IncompleteHandler(DirectAPIJobHandler):
            ACTION_CODE = "incomplete"

            def get_service(self):
                return Mock()

            def create_tasks(self, job):
                return []

        with pytest.raises(TypeError, match="Can't instantiate abstract class"):
            IncompleteHandler(db=db_session, shop_id=123, job_id=1)
```

**Run Tests**:
```bash
cd backend
source .venv/bin/activate
pytest tests/unit/services/test_direct_api_job_handler.py -v
```

**Expected Output**:
```
tests/unit/services/test_direct_api_job_handler.py::TestDirectAPIJobHandlerValidation::test_execute_fails_if_no_product_id PASSED
tests/unit/services/test_direct_api_job_handler.py::TestDirectAPIJobHandlerValidation::test_execute_validates_product_id_before_service_call PASSED
tests/unit/services/test_direct_api_job_handler.py::TestDirectAPIJobHandlerServiceDelegation::test_execute_calls_service_method PASSED
tests/unit/services/test_direct_api_job_handler.py::TestDirectAPIJobHandlerServiceDelegation::test_execute_uses_get_service_method PASSED
tests/unit/services/test_direct_api_job_handler.py::TestDirectAPIJobHandlerServiceDelegation::test_execute_returns_service_result PASSED
tests/unit/services/test_direct_api_job_handler.py::TestDirectAPIJobHandlerResultHandling::test_execute_handles_success_result PASSED
tests/unit/services/test_direct_api_job_handler.py::TestDirectAPIJobHandlerResultHandling::test_execute_handles_etsy_listing_id PASSED
tests/unit/services/test_direct_api_job_handler.py::TestDirectAPIJobHandlerResultHandling::test_execute_handles_service_error PASSED
tests/unit/services/test_direct_api_job_handler.py::TestDirectAPIJobHandlerExceptionHandling::test_execute_catches_service_exception PASSED
tests/unit/services/test_direct_api_job_handler.py::TestDirectAPIJobHandlerExceptionHandling::test_execute_catches_network_exception PASSED
tests/unit/services/test_direct_api_job_handler.py::TestDirectAPIJobHandlerExceptionHandling::test_execute_returns_standardized_error_dict PASSED
tests/unit/services/test_direct_api_job_handler.py::TestDirectAPIJobHandlerAbstractMethods::test_cannot_instantiate_without_get_service PASSED
tests/unit/services/test_direct_api_job_handler.py::TestDirectAPIJobHandlerAbstractMethods::test_cannot_instantiate_without_get_service_method_name PASSED

==================== 13 passed in 0.25s ====================
```

**Verification**:
- [ ] Test file created with 13 comprehensive tests
- [ ] Tests cover validation, service delegation, result handling, exceptions
- [ ] Tests verify abstract method enforcement
- [ ] All tests pass (13/13 PASS)
- [ ] Test coverage >90% for DirectAPIJobHandler
    </instruction>
  </task>
</tasks>

<verification>
## Success Criteria

- [ ] `DirectAPIJobHandler` class exists in `backend/services/marketplace/direct_api_job_handler.py`
- [ ] Extends `BaseJobHandler` correctly
- [ ] Defines two abstract methods: `get_service()`, `get_service_method_name()`
- [ ] Implements common `execute()` pattern (validation → service call → result handling → exceptions)
- [ ] Usage examples in docstring show 81% code reduction (81 lines → 15 lines)
- [ ] Test file with 13 tests created and all passing
- [ ] Test coverage >90% for new class
- [ ] No changes to existing eBay/Etsy handlers (migration is Phase 4+)
- [ ] No breaking changes (existing handlers continue working unchanged)

## Commit Message

```
feat(phase-3): add DirectAPIJobHandler base class

Create base class to factorize eBay/Etsy handler duplication.

- Extracts common patterns: validation, service delegation, result handling
- Defines abstract methods: get_service(), get_service_method_name()
- Reduces handler code by 81% (81 lines → 15 lines per handler)
- Saves 660 lines total across 10 handlers (to be migrated in Phase 4+)
- Adds 13 comprehensive tests with >90% coverage
- Zero breaking changes (existing handlers unchanged)

Phase: 03-directapi-handler-base (Plan 03-01)
Next: Phase 4 will migrate eBay handlers to use this base class
```

## Testing

Run tests to verify implementation:

```bash
cd backend
source .venv/bin/activate

# Run unit tests for DirectAPIJobHandler
pytest tests/unit/services/test_direct_api_job_handler.py -v

# Verify no regressions in existing handlers (should still pass)
pytest tests/unit/services/ebay/ -v
pytest tests/unit/services/etsy/ -v
```
</verification>

<success_criteria>
✅ DirectAPIJobHandler class created with proper abstraction
✅ Common execute() pattern factorized (5 steps)
✅ Abstract methods enforce subclass contracts
✅ Usage examples demonstrate 81% code reduction
✅ 13 comprehensive tests with >90% coverage
✅ All tests passing (new + existing)
✅ Zero breaking changes to existing handlers
✅ Ready for Phase 4 (eBay handler migration)
</success_criteria>

<output>
## SUMMARY.md Specification

Create `03-01-SUMMARY.md` with:

### Structure

1. **Accomplissements**: DirectAPIJobHandler base class created
2. **Fonctionnalités Implémentées**:
   - Abstract methods (get_service, get_service_method_name)
   - Common execute() pattern (5 steps)
   - Usage examples
3. **Code Metrics**:
   - Lines saved: 660 total (66 per handler × 10 handlers)
   - Reduction: 81% (81 lines → 15 lines)
   - Tests: 13 tests, >90% coverage
4. **Architecture Diagram**: Show BaseJobHandler → DirectAPIJobHandler → eBay/Etsy handlers
5. **Commits Créés**: List commits with types (feat, test, docs)
6. **Prochaines Étapes**: Phase 4 - Migrate eBay handlers

### Metrics to Include

- Code duplication before: 810 lines (81 per handler × 10 handlers)
- Code after migration: 150 lines (15 per handler × 10 handlers)
- Savings: 660 lines (81% reduction)
- Tests added: 13 tests
- Test coverage: >90%
- Duration: ~X hours
</output>
