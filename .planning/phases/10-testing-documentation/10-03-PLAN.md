# Plan 10-03: Architecture Documentation

**Phase:** 10 - Testing & Documentation
**Plan:** 10-03
**Created:** 2026-01-16
**Status:** Ready for execution

---

## Objective

Document the unified MarketplaceJob orchestration system with comprehensive architecture documentation, API documentation, and inline code comments.

**Purpose**: Provide clear documentation for developers working with the task orchestration system, making it easy to understand the architecture, use the APIs correctly, and maintain the codebase.

**Output**: Complete ARCHITECTURE.md, updated API documentation, and well-commented complex code sections.

---

## Execution Context

### Prerequisites
- ✅ Phase 10-01 completed (unit tests)
- ✅ Phase 10-02 completed (integration tests)
- ✅ Task orchestration system fully implemented (Phases 6-9)
- ✅ Test coverage: 57%

### Dependencies
- MarketplaceJob system (unified architecture from Phase 9)
- API routes in `backend/api/`
- Service layer in `backend/services/marketplace/`
- Models in `backend/models/user/`

### References
```
@backend/services/marketplace/marketplace_job_processor.py
@backend/services/marketplace/marketplace_job_service.py
@backend/services/marketplace/handlers/base_handler.py
@backend/models/user/marketplace_job.py
@backend/models/user/marketplace_task.py
@backend/models/user/batch_job.py
@.planning/ROADMAP.md (Target Architecture section)
```

---

## Context

### What Was Accomplished in Phases 10-01 and 10-02

From `.planning/phases/10-testing-documentation/10-01-SUMMARY.md`:
- 90 unit tests created for 4 services
- Coverage: 51.1% → 53.0%

From integration tests (10-02):
- 25+ integration tests for job workflows
- Coverage: 53.0% → 57%
- All critical workflows validated

### Why Documentation Is Critical

From ROADMAP.md Phase 10:
> **Deliverables:**
> - Architecture documentation (ARCHITECTURE.md)
> - API documentation updates
> - Code comments for complex task logic

**Benefits**:
1. **Onboarding**: New developers understand the system quickly
2. **Maintenance**: Clear patterns for extending functionality
3. **API Usage**: Correct integration by frontend/external consumers
4. **Debugging**: Well-commented code is easier to troubleshoot

### System Architecture Overview

The unified task orchestration system has 3 levels:

```
BatchJob (parent orchestrator)
├── MarketplaceJob (operation: publish, update, delete, sync)
│   ├── MarketplaceTask (validate product data)
│   ├── MarketplaceTask (map data to marketplace format)
│   ├── MarketplaceTask (upload images)
│   ├── MarketplaceTask (create listing)
│   └── MarketplaceTask (save result)
```

**Key Principles**:
1. **Granularity**: 1 task = 1 functional step
2. **Idempotence**: Each task checks side-effects before executing
3. **Retry Logic**: Skip COMPLETED tasks, retry only FAILED
4. **Progress Tracking**: Real-time visibility at all levels

---

## Tasks

### Task 1: Create ARCHITECTURE.md Documentation

**Goal:** Document the task orchestration system architecture comprehensively.

**File:** `backend/ARCHITECTURE.md`

**Content Structure:**
```markdown
# StoFlow Backend Architecture

## Overview
[System purpose and high-level design]

## Task Orchestration System
### Three-Level Hierarchy
- BatchJob: Parent orchestrator
- MarketplaceJob: Individual operations
- MarketplaceTask: Granular execution steps

### Key Models
- BatchJob (models/user/batch_job.py)
- MarketplaceJob (models/user/marketplace_job.py)
- MarketplaceTask (models/user/marketplace_task.py)

### Service Layer
- MarketplaceJobService: Job CRUD operations
- MarketplaceJobProcessor: Job execution orchestration
- BaseJobHandler: Handler pattern (WebSocket + HTTP)

### Handler Architecture
- BaseJobHandler: Abstract base for all handlers
- DirectAPIJobHandler: For eBay/Etsy (direct HTTP)
- VintedPublishHandler: For Vinted (WebSocket via plugin)

### State Machine
[Job status flow diagram: PENDING → PROCESSING → COMPLETED/FAILED]

### Retry Logic
- Idempotence checks before task execution
- Skip COMPLETED tasks on retry
- Retry only FAILED tasks
- Commit after each task (granular tracking)

### Multi-Tenant Architecture
- Schema-based isolation (user_1, user_2, etc.)
- schema_translate_map for tenant context
- Automatic schema switching per request

## API Design
### Job Endpoints
- POST /api/marketplace/jobs - Create job
- GET /api/marketplace/jobs/:id - Get job status
- GET /api/marketplace/jobs - List jobs (filtered)
- POST /api/marketplace/jobs/:id/retry - Retry failed job

### Task Endpoints
- GET /api/marketplace/tasks - List tasks for job
- GET /api/marketplace/tasks/:id - Get task details

### BatchJob Endpoints
- POST /api/batch-jobs - Create batch
- GET /api/batch-jobs/:id - Get batch progress

## Database Schema
### Tables
- marketplace_jobs (tenant schema)
- marketplace_tasks (tenant schema)
- batch_jobs (tenant schema)
- marketplace_action_types (public schema)

### Relationships
- BatchJob → MarketplaceJob (one-to-many)
- MarketplaceJob → MarketplaceTask (one-to-many)
- MarketplaceJob → MarketplaceActionType (foreign key)

## Design Patterns
### Handler Pattern
[Explanation of BaseJobHandler abstraction]

### Factory Pattern
[How handlers are instantiated based on marketplace]

### Strategy Pattern
[How different marketplaces use different communication strategies]

## Extension Guide
### Adding a New Marketplace
1. Create handler class extending BaseJobHandler or DirectAPIJobHandler
2. Implement execute_job() method
3. Create marketplace-specific tasks
4. Register in handler factory

### Adding a New Action Type
1. Add to marketplace_action_types table
2. Create tasks in handler
3. Update API endpoints if needed

## Testing Strategy
- Unit tests: Service layer (90+ tests)
- Integration tests: Full workflows (25+ tests)
- Coverage target: >80% for critical paths

## Performance Considerations
- Task commits: 1 task = 1 DB commit (monitoring)
- Batch processing: Parallelization opportunities
- Query optimization: Eager loading for job → tasks

## Security
- Multi-tenant isolation (schema-based)
- Input validation (Pydantic schemas)
- Authentication required for all endpoints
- Authorization per tenant (user_id checks)

## Troubleshooting
### Common Issues
- Job stuck in PROCESSING: Check plugin connectivity (Vinted)
- Tasks not retrying: Verify idempotence logic
- Schema errors: Verify schema_translate_map configuration

### Debugging
- Check logs: backend/logs/
- Inspect job status: GET /api/marketplace/jobs/:id
- View task details: GET /api/marketplace/tasks?job_id=:id
```

**Verification:**
```bash
# Verify file created
cat backend/ARCHITECTURE.md | head -20

# Check all sections present
grep "## " backend/ARCHITECTURE.md

# Verify markdown formatting
npx markdownlint backend/ARCHITECTURE.md
```

**Done:** ARCHITECTURE.md exists with all sections, properly formatted, covering the full system architecture.

---

### Task 2: Update API Documentation for Task Status Endpoints

**Goal:** Document all API endpoints related to jobs, tasks, and batches with request/response examples.

**Files:**
- `backend/api/docs/jobs_api.md` (create if doesn't exist)
- `backend/api/docs/tasks_api.md` (create if doesn't exist)
- `backend/api/docs/batch_jobs_api.md` (create if doesn't exist)

**Content for Each Endpoint:**

```markdown
# Job API Documentation

## POST /api/marketplace/jobs

Create a new marketplace job.

**Authentication:** Required

**Request Body:**
```json
{
  "marketplace": "vinted",
  "action_code": "publish",
  "product_id": 123,
  "user_id": 1
}
```

**Response (201 Created):**
```json
{
  "id": 456,
  "marketplace": "vinted",
  "action_code": "publish",
  "status": "pending",
  "product_id": 123,
  "user_id": 1,
  "created_at": "2026-01-16T10:30:00Z",
  "updated_at": "2026-01-16T10:30:00Z"
}
```

**Error Responses:**
- 400: Invalid request body
- 401: Unauthorized
- 404: Product not found

---

## GET /api/marketplace/jobs/:id

Get job status and details.

**Authentication:** Required

**Path Parameters:**
- `id` (integer): Job ID

**Response (200 OK):**
```json
{
  "id": 456,
  "marketplace": "vinted",
  "action_code": "publish",
  "status": "completed",
  "product_id": 123,
  "user_id": 1,
  "created_at": "2026-01-16T10:30:00Z",
  "updated_at": "2026-01-16T10:35:00Z",
  "completed_at": "2026-01-16T10:35:00Z",
  "tasks": [
    {
      "id": 789,
      "task_type": "plugin_http",
      "status": "success",
      "description": "Publish product to Vinted"
    }
  ]
}
```

**Error Responses:**
- 401: Unauthorized
- 404: Job not found

---

[Continue for all endpoints: GET /jobs, POST /jobs/:id/retry, etc.]
```

**Verification:**
```bash
# Verify files created
ls backend/api/docs/*.md

# Check all endpoints documented
grep "## GET\|## POST\|## PUT\|## DELETE" backend/api/docs/*.md

# Verify JSON examples are valid
cat backend/api/docs/jobs_api.md | grep -A 20 "```json"
```

**Done:** API documentation files exist with all endpoints, request/response examples, and error codes documented.

---

### Task 3: Add Code Comments for Complex Task Logic

**Goal:** Add comprehensive inline comments to complex code sections for maintainability.

**Files to Comment:**
1. `backend/services/marketplace/marketplace_job_processor.py` - Main orchestrator logic
2. `backend/services/marketplace/handlers/base_handler.py` - Handler pattern
3. `backend/services/marketplace/marketplace_job_service.py` - Retry logic
4. `backend/models/user/marketplace_task.py` - Task state machine

**Comment Standards:**
- **Why over what**: Explain why code exists, not just what it does
- **Docstrings**: Google-style for all public methods
- **Inline comments**: For non-obvious logic, edge cases, workarounds

**Example for marketplace_job_processor.py:**
```python
def process_job(self, job_id: int) -> MarketplaceJob:
    """
    Process a marketplace job by executing its tasks sequentially.

    This is the main orchestrator that:
    1. Loads the job and its tasks
    2. Sets schema context for multi-tenant isolation
    3. Executes tasks one by one (idempotence checks)
    4. Commits after each task (granular tracking)
    5. Updates job status based on task results

    Args:
        job_id: ID of the job to process

    Returns:
        Updated MarketplaceJob with final status

    Raises:
        JobNotFoundError: If job doesn't exist
        SchemaNotFoundError: If tenant schema missing
    """
    # Load job with tasks eagerly (avoid N+1 queries)
    job = self._load_job_with_tasks(job_id)

    # Set schema context for tenant isolation
    # This ensures all DB operations happen in the correct user_X schema
    self._set_schema_context(job.user_id)

    # Get handler for this marketplace (factory pattern)
    handler = self._get_handler(job.marketplace)

    # Execute each task with idempotence check
    for task in job.tasks:
        # Skip completed tasks on retry (idempotence)
        # This is critical: we never re-execute successful tasks
        if task.status == TaskStatus.SUCCESS:
            logger.info(f"Skipping completed task {task.id}")
            continue

        # Execute task (handler-specific logic)
        try:
            handler.execute_task(task)
            task.status = TaskStatus.SUCCESS
        except Exception as e:
            task.status = TaskStatus.FAILED
            task.error_message = str(e)
            logger.error(f"Task {task.id} failed: {e}")

        # Commit after each task (granular progress tracking)
        # Frontend can poll for real-time updates
        self.db.commit()

    # Update job status based on task results
    job.status = self._calculate_job_status(job)
    self.db.commit()

    return job
```

**Areas Requiring Comments**:
- Retry logic (skip COMPLETED tasks)
- Idempotence checks (side-effect detection)
- Schema switching (multi-tenant context)
- Handler factory (marketplace selection)
- Status transitions (state machine rules)
- Error handling patterns

**Verification:**
```bash
# Check comments added
grep -n "# " backend/services/marketplace/marketplace_job_processor.py | wc -l

# Verify docstrings present
grep -n '"""' backend/services/marketplace/*.py | wc -l

# Check Google-style docstring format
grep -A 5 "Args:" backend/services/marketplace/marketplace_job_service.py
```

**Done:** All complex code sections have explanatory comments, all public methods have Google-style docstrings.

---

## Verification

After completing all tasks:

```bash
# Verify ARCHITECTURE.md exists and is complete
cat backend/ARCHITECTURE.md | grep "## " | wc -l  # Should show 10+ sections

# Verify API docs exist
ls backend/api/docs/*.md  # Should show 3 files

# Verify comments added to code
for file in backend/services/marketplace/*.py; do
  echo "$file: $(grep -c '"""' $file) docstrings, $(grep -c '# ' $file) inline comments"
done

# Check markdown formatting
npx markdownlint backend/*.md backend/api/docs/*.md
```

**Expected Results:**
- ✅ ARCHITECTURE.md with 10+ sections
- ✅ 3 API documentation files (jobs, tasks, batch_jobs)
- ✅ 50+ new docstrings across services
- ✅ 100+ inline comments explaining complex logic
- ✅ All markdown files properly formatted

---

## Success Criteria

- [ ] ARCHITECTURE.md created with comprehensive system documentation
- [ ] All sections present: Overview, Models, Services, Handlers, State Machine, Retry Logic, Multi-Tenant, API, Database, Patterns, Extension Guide, Testing, Performance, Security, Troubleshooting
- [ ] API documentation files created for jobs, tasks, and batch_jobs endpoints
- [ ] All endpoints documented with request/response examples and error codes
- [ ] Complex code sections commented with explanatory comments
- [ ] All public methods have Google-style docstrings
- [ ] Markdown files are properly formatted (pass markdownlint)
- [ ] Documentation is clear, concise, and actionable

---

## Output

### Files Created
- `backend/ARCHITECTURE.md`
- `backend/api/docs/jobs_api.md`
- `backend/api/docs/tasks_api.md`
- `backend/api/docs/batch_jobs_api.md`

### Files Modified
- `backend/services/marketplace/marketplace_job_processor.py` (comments added)
- `backend/services/marketplace/marketplace_job_service.py` (comments added)
- `backend/services/marketplace/handlers/base_handler.py` (comments added)
- `backend/models/user/marketplace_task.py` (comments added)

### Total Estimated Lines
- ARCHITECTURE.md: ~500 lines
- API docs: ~400 lines total
- Code comments: ~200 lines

---

## Notes

### Documentation Philosophy

Following pragmatic documentation approach:
- **Code explains "how"**, **comments explain "why"**
- **Architecture doc**: High-level design decisions and patterns
- **API docs**: Practical usage examples
- **Inline comments**: Non-obvious logic, edge cases, workarounds

### Maintenance

Documentation should be updated when:
- New marketplace added (extend Architecture doc)
- New API endpoint added (update API docs)
- Complex logic changed (update inline comments)

### Style Guide

- Use **Google-style docstrings** for consistency with existing code
- Use **Markdown** for all documentation files
- Use **code examples** liberally (easier to understand)
- Keep sentences **short and clear**

---

*Plan created: 2026-01-16*
*Ready for execution via `/gsd:execute-plan`*
