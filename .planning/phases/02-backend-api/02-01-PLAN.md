---
phase: 02-backend-api
plan: 01
type: execute
---

<objective>
Créer les endpoints REST pour la génération de textes produits (titres SEO et descriptions).

Purpose: Exposer le service ProductTextGeneratorService via API REST pour l'intégration frontend.
Output: 2 endpoints fonctionnels — generate (produit existant) et preview (attributs bruts).
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-phase.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-backend-service/01-02-SUMMARY.md

**Service from Phase 1:**
@backend/services/product_text_generator.py

**API Pattern Reference:**
@backend/api/pricing.py (route pattern)
@backend/schemas/pricing.py (schema pattern)

**Dependencies module:**
@backend/api/dependencies/__init__.py

**Tech stack available:**
- FastAPI with Pydantic v2
- SQLAlchemy session via get_user_db()
- JWT auth via get_current_user()

**Established patterns:**
- Service layer pattern (route delegates to service)
- Dependency injection (db_user tuple)
- Custom exceptions → HTTPException conversion
- Google-style docstrings

**Constraining decisions from Phase 1:**
- Service uses static methods (no DB dependency)
- generate_all(product) returns dict with titles/descriptions
- generate_preview(attributes) accepts raw dict
- TitleFormat and DescriptionStyle enums for format/style selection

**Endpoints to create:**

1. `POST /products/text/generate`
   - Input: product_id + optional title_format + description_style
   - Fetches product from DB, calls service
   - Returns all generated texts

2. `POST /products/text/preview`
   - Input: raw attributes dict
   - No DB fetch, calls generate_preview()
   - For form preview before save
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pydantic schemas for text generation</name>
  <files>backend/schemas/text_generator.py</files>
  <action>
Create new schema file with:

1. **TextGenerateInput** - Request schema for /generate endpoint:
```python
class TextGenerateInput(BaseModel):
    """Input for generating text from existing product."""
    product_id: int = Field(..., description="Product ID to generate text for")
    title_format: Optional[int] = Field(None, ge=1, le=3, description="Title format (1=Ultra Complete, 2=Technical, 3=Style & Trend)")
    description_style: Optional[int] = Field(None, ge=1, le=3, description="Description style (1=Professional, 2=Storytelling, 3=Minimalist)")
```

2. **TextPreviewInput** - Request schema for /preview endpoint:
```python
class TextPreviewInput(BaseModel):
    """Input for preview from raw attributes (before save)."""
    brand: Optional[str] = None
    category: Optional[str] = None
    gender: Optional[str] = None
    size_normalized: Optional[str] = None
    colors: Optional[list[str]] = None
    material: Optional[str] = None
    fit: Optional[str] = None
    condition: Optional[int] = Field(None, ge=0, le=10)
    decade: Optional[str] = None
    rise: Optional[str] = None
    closure: Optional[str] = None
    unique_feature: Optional[list[str]] = None
    pattern: Optional[str] = None
    trend: Optional[str] = None
    season: Optional[str] = None
    origin: Optional[str] = None
    condition_sup: Optional[list[str]] = None
```

3. **TextGeneratorOutput** - Response schema:
```python
class TextGeneratorOutput(BaseModel):
    """Output with all generated titles and descriptions."""
    titles: dict[str, str] = Field(..., description="Generated titles by format key")
    descriptions: dict[str, str] = Field(..., description="Generated descriptions by style key")

    model_config = ConfigDict(from_attributes=True)
```

Follow existing schema patterns (Google docstrings, Field with descriptions).
  </action>
  <verify>
cd backend && python -c "
from schemas.text_generator import TextGenerateInput, TextPreviewInput, TextGeneratorOutput
print('TextGenerateInput fields:', list(TextGenerateInput.model_fields.keys()))
print('TextPreviewInput fields:', list(TextPreviewInput.model_fields.keys()))
print('TextGeneratorOutput fields:', list(TextGeneratorOutput.model_fields.keys()))
print('All schemas OK')
"
  </verify>
  <done>Schemas created and importable. All fields validated.</done>
</task>

<task type="auto">
  <name>Task 2: Create FastAPI endpoints for text generation</name>
  <files>backend/api/text_generator.py, backend/main.py</files>
  <action>
1. **Create router file** `backend/api/text_generator.py`:

```python
"""
Text Generator API Routes

REST API endpoints for generating SEO-optimized titles and descriptions.
Uses ProductTextGeneratorService (pure Python templates, no LLM).

Endpoints:
- POST /products/text/generate - Generate from existing product
- POST /products/text/preview - Preview from raw attributes
"""

router = APIRouter(prefix="/products/text", tags=["Text Generation"])
```

2. **POST /products/text/generate** endpoint:
- Depends on get_user_db (for DB access + multi-tenant)
- Depends on get_current_user (authentication)
- Fetch product by ID from user's schema
- If product not found → 404
- Call ProductTextGeneratorService.generate_all(product)
- If specific format/style requested, filter output
- Return TextGeneratorOutput

3. **POST /products/text/preview** endpoint:
- Depends on get_current_user (authentication only, no DB needed for preview)
- Convert TextPreviewInput to dict
- Call ProductTextGeneratorService.generate_preview(attributes)
- Return TextGeneratorOutput

4. **Register router** in `backend/main.py`:
- Import: `from api.text_generator import router as text_generator_router`
- Add: `app.include_router(text_generator_router)`

**Error handling:**
- Product not found → HTTPException 404
- Invalid format/style → Pydantic validation handles (400)
- Service error → HTTPException 500 with generic message

**Logging:**
- Log requests with user_id, product_id
- Log response time for performance monitoring
  </action>
  <verify>
cd backend && python -c "
from fastapi.testclient import TestClient
from main import app

# Check routes are registered
routes = [r.path for r in app.routes]
assert '/products/text/generate' in routes or any('/products/text' in r for r in routes), 'Routes not registered'
print('Routes registered:', [r for r in routes if 'text' in r])

# Check imports work
from api.text_generator import router
print('Router prefix:', router.prefix)
print('Router tags:', router.tags)
print('All endpoints OK')
"
  </verify>
  <done>Endpoints created and registered. Routes accessible at /products/text/generate and /products/text/preview.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `from schemas.text_generator import TextGenerateInput, TextPreviewInput, TextGeneratorOutput` succeeds
- [ ] `from api.text_generator import router` succeeds
- [ ] Router registered in main.py
- [ ] Routes /products/text/generate and /products/text/preview exist
- [ ] Endpoints have proper docstrings and OpenAPI documentation
</verification>

<success_criteria>
- Schema file created at `backend/schemas/text_generator.py`
- Router file created at `backend/api/text_generator.py`
- Router registered in `backend/main.py`
- POST /products/text/generate endpoint works
- POST /products/text/preview endpoint works
- Proper error handling (404, 400, 500)
- Phase 2 complete - API ready for frontend integration
</success_criteria>

<output>
After completion, create `.planning/phases/02-backend-api/02-01-SUMMARY.md` with:
- Endpoints created
- Ready for Phase 3 (User Settings) or Phase 4 (Frontend Composable)
</output>
