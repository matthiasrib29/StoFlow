---
phase: 04-frontend-composable
plan: 01
type: execute
---

<objective>
Créer le composable `useProductTextGenerator.ts` pour l'intégration frontend du générateur de texte.

Purpose: Permettre aux pages de création/édition de produits d'utiliser facilement la génération de titres et descriptions.
Output: Composable TypeScript avec generate, preview, settings management et state management.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-phase.md
./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-backend-api/02-01-SUMMARY.md
@.planning/phases/03-user-settings/03-01-SUMMARY.md

**Backend API from Phase 2:**
@backend/api/text_generator.py
@backend/schemas/text_generator.py

**User settings API from Phase 3:**
@backend/api/user_settings.py
@backend/schemas/user_settings.py

**Composable pattern reference:**
@frontend/composables/useApi.ts

**Tech stack available:**
- Vue 3 Composition API with `<script setup>`
- Nuxt auto-imports for composables
- TypeScript 5.9
- useApi() for authenticated API calls

**Established patterns:**
- Composables return refs, computed, and methods
- Logging via `apiLogger` from `~/utils/logger`
- Types defined in `~/types/`

**Constraining decisions from previous phases:**
- TitleFormat: 1=Ultra Complete, 2=Technical, 3=Style & Trend
- DescriptionStyle: 1=Professional, 2=Storytelling, 3=Minimalist
- API endpoints: POST /products/text/generate, POST /products/text/preview
- Settings endpoints: GET/PATCH /users/me/settings/text-generator
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TypeScript types for text generator</name>
  <files>frontend/types/textGenerator.ts</files>
  <action>
Create TypeScript interfaces matching the backend schemas:

```typescript
// Title format options (1-3)
export type TitleFormat = 1 | 2 | 3
export const TITLE_FORMAT_LABELS: Record<TitleFormat, string> = {
  1: 'Ultra Complete',
  2: 'Technical',
  3: 'Style & Trend'
}

// Description style options (1-3)
export type DescriptionStyle = 1 | 2 | 3
export const DESCRIPTION_STYLE_LABELS: Record<DescriptionStyle, string> = {
  1: 'Professional',
  2: 'Storytelling',
  3: 'Minimalist'
}

// API input for generate (existing product)
export interface TextGenerateInput {
  product_id: number
  title_format?: TitleFormat
  description_style?: DescriptionStyle
}

// API input for preview (raw attributes)
export interface TextPreviewInput {
  brand?: string
  category?: string
  gender?: string
  size_normalized?: string
  colors?: string[]
  material?: string
  fit?: string
  condition?: number
  decade?: string
  rise?: string
  closure?: string
  unique_feature?: string[]
  pattern?: string
  trend?: string
  season?: string
  origin?: string
  condition_sup?: string[]
}

// API output
export interface TextGeneratorOutput {
  titles: Record<string, string>
  descriptions: Record<string, string>
}

// User settings
export interface TextGeneratorSettings {
  default_title_format: TitleFormat | null
  default_description_style: DescriptionStyle | null
}
```
  </action>
  <verify>
cd frontend && npx tsc --noEmit types/textGenerator.ts 2>/dev/null || echo "Types OK (Nuxt handles TS)"
  </verify>
  <done>TypeScript types created and valid. File exists at frontend/types/textGenerator.ts</done>
</task>

<task type="auto">
  <name>Task 2: Create useProductTextGenerator composable</name>
  <files>frontend/composables/useProductTextGenerator.ts</files>
  <action>
Create the main composable with the following features:

1. **State management:**
   - `titles: Ref<Record<string, string>>` - Generated titles
   - `descriptions: Ref<Record<string, string>>` - Generated descriptions
   - `loading: Ref<boolean>` - Loading state for any operation
   - `error: Ref<string | null>` - Error message
   - `settings: Ref<TextGeneratorSettings | null>` - User's default settings

2. **API methods:**
   - `generate(productId: number, options?: { titleFormat?: TitleFormat, descriptionStyle?: DescriptionStyle })` - Generate from existing product
   - `preview(attributes: TextPreviewInput)` - Preview from raw attributes
   - `loadSettings()` - Load user's default settings
   - `saveSettings(settings: Partial<TextGeneratorSettings>)` - Save default settings

3. **Computed properties:**
   - `hasResults: ComputedRef<boolean>` - Whether results are available
   - `titleFormatOptions` - Array of {value, label} for select dropdowns
   - `descriptionStyleOptions` - Array of {value, label} for select dropdowns

4. **Implementation pattern:**
```typescript
export function useProductTextGenerator() {
  const { post, get, patch } = useApi()

  // State
  const titles = ref<Record<string, string>>({})
  const descriptions = ref<Record<string, string>>({})
  const loading = ref(false)
  const error = ref<string | null>(null)
  const settings = ref<TextGeneratorSettings | null>(null)

  // Methods
  const generate = async (productId: number, options?: {...}) => {
    loading.value = true
    error.value = null
    try {
      const result = await post<TextGeneratorOutput>('/products/text/generate', {
        product_id: productId,
        title_format: options?.titleFormat,
        description_style: options?.descriptionStyle
      })
      titles.value = result.titles
      descriptions.value = result.descriptions
    } catch (e: any) {
      error.value = e.message
    } finally {
      loading.value = false
    }
  }

  // ... similar for preview, loadSettings, saveSettings

  return {
    // State (readonly)
    titles: readonly(titles),
    descriptions: readonly(descriptions),
    loading: readonly(loading),
    error: readonly(error),
    settings: readonly(settings),
    // Computed
    hasResults,
    titleFormatOptions,
    descriptionStyleOptions,
    // Methods
    generate,
    preview,
    loadSettings,
    saveSettings,
    clearResults
  }
}
```

Use `readonly()` for state exports to enforce read-only access from components.
Log operations with appropriate context (user_id implicit via JWT).
  </action>
  <verify>
cd frontend && python3 -c "
import os
path = 'composables/useProductTextGenerator.ts'
if os.path.exists(path):
    with open(path) as f:
        content = f.read()
        checks = [
            'export function useProductTextGenerator' in content,
            'generate' in content,
            'preview' in content,
            'loadSettings' in content,
            'saveSettings' in content,
            'readonly' in content
        ]
        print('All checks:', all(checks))
        for i, c in enumerate(['export', 'generate', 'preview', 'loadSettings', 'saveSettings', 'readonly']):
            print(f'  {c}: {checks[i]}')
else:
    print('File not found')
"
  </verify>
  <done>Composable created with generate, preview, loadSettings, saveSettings methods and proper state management.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `frontend/types/textGenerator.ts` exists with all interfaces
- [ ] `frontend/composables/useProductTextGenerator.ts` exists
- [ ] Composable exports: generate, preview, loadSettings, saveSettings, clearResults
- [ ] Composable exports readonly state: titles, descriptions, loading, error, settings
- [ ] TypeScript compiles without errors (Nuxt handles this)
</verification>

<success_criteria>
- Types file created at `frontend/types/textGenerator.ts`
- Composable file created at `frontend/composables/useProductTextGenerator.ts`
- All 4 API methods implemented (generate, preview, loadSettings, saveSettings)
- State management with readonly exports
- Ready for Phase 5 (Frontend UI integration)
</success_criteria>

<output>
After completion, create `.planning/phases/04-frontend-composable/04-01-SUMMARY.md` with:
- Types created
- Composable methods and state
- Ready for Phase 5 (Frontend UI)
</output>
